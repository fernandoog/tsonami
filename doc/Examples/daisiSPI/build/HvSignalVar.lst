ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 1


   1              		.cpu cortex-m7
   2              		.arch armv7e-m
   3              		.fpu fpv5-d16
   4              		.eabi_attribute 28, 1
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 2
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.file	"HvSignalVar.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata.msg_getFloat.part.0.str1.4,"aMS",%progbits,1
  19              		.align	2
  20              	.LC0:
  21 0000 696E6465 		.ascii	"index < msg_getNumElements(m)\000"
  21      78203C20 
  21      6D73675F 
  21      6765744E 
  21      756D456C 
  22 001e 0000     		.align	2
  23              	.LC1:
  24 0020 736F7572 		.ascii	"source/HvMessage.h\000"
  24      63652F48 
  24      764D6573 
  24      73616765 
  24      2E6800
  25              		.section	.text.msg_getFloat.part.0,"ax",%progbits
  26              		.align	1
  27              		.p2align 2,,3
  28              		.syntax unified
  29              		.thumb
  30              		.thumb_func
  32              	msg_getFloat.part.0:
  33              	.LFB409:
  34              		.file 1 "source/HvMessage.h"
   1:source/HvMessage.h **** /**
   2:source/HvMessage.h ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvMessage.h ****  *
   4:source/HvMessage.h ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvMessage.h ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvMessage.h ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvMessage.h ****  *
   8:source/HvMessage.h ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvMessage.h ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvMessage.h ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvMessage.h ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvMessage.h ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvMessage.h ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvMessage.h ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvMessage.h ****  */
  16:source/HvMessage.h **** 
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 2


  17:source/HvMessage.h **** #ifndef _HEAVY_MESSAGE_H_
  18:source/HvMessage.h **** #define _HEAVY_MESSAGE_H_
  19:source/HvMessage.h **** 
  20:source/HvMessage.h **** #include "HvUtils.h"
  21:source/HvMessage.h **** 
  22:source/HvMessage.h **** #ifdef __cplusplus
  23:source/HvMessage.h **** extern "C" {
  24:source/HvMessage.h **** #endif
  25:source/HvMessage.h **** 
  26:source/HvMessage.h **** typedef enum ElementType {
  27:source/HvMessage.h ****   HV_MSG_BANG = 0,
  28:source/HvMessage.h ****   HV_MSG_FLOAT = 1,
  29:source/HvMessage.h ****   HV_MSG_SYMBOL = 2,
  30:source/HvMessage.h ****   HV_MSG_HASH = 3
  31:source/HvMessage.h **** } ElementType;
  32:source/HvMessage.h **** 
  33:source/HvMessage.h **** typedef struct Element {
  34:source/HvMessage.h ****   ElementType type;
  35:source/HvMessage.h ****   union {
  36:source/HvMessage.h ****     float f; // float
  37:source/HvMessage.h ****     const char *s; // symbol
  38:source/HvMessage.h ****     hv_uint32_t h; // hash
  39:source/HvMessage.h ****   } data;
  40:source/HvMessage.h **** } Element;
  41:source/HvMessage.h **** 
  42:source/HvMessage.h **** typedef struct HvMessage {
  43:source/HvMessage.h ****   hv_uint32_t timestamp; // the sample at which this message should be processed
  44:source/HvMessage.h ****   hv_uint16_t numElements;
  45:source/HvMessage.h ****   hv_uint16_t numBytes; // the total number of bytes that this message occupies in memory, includin
  46:source/HvMessage.h ****   Element elem;
  47:source/HvMessage.h **** } HvMessage;
  48:source/HvMessage.h **** 
  49:source/HvMessage.h **** typedef struct ReceiverMessagePair {
  50:source/HvMessage.h ****   hv_uint32_t receiverHash;
  51:source/HvMessage.h ****   HvMessage msg;
  52:source/HvMessage.h **** } ReceiverMessagePair;
  53:source/HvMessage.h **** 
  54:source/HvMessage.h **** #define HV_MESSAGE_ON_STACK(_x) (HvMessage *) hv_alloca(msg_getCoreSize(_x))
  55:source/HvMessage.h **** 
  56:source/HvMessage.h **** /** Returns the number of bytes that this message consumes in memory, not including strings. */
  57:source/HvMessage.h **** static inline hv_size_t msg_getCoreSize(hv_size_t numElements) {
  58:source/HvMessage.h ****   hv_assert(numElements > 0);
  59:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
  60:source/HvMessage.h **** }
  61:source/HvMessage.h **** 
  62:source/HvMessage.h **** HvMessage *msg_copy(const HvMessage *m);
  63:source/HvMessage.h **** 
  64:source/HvMessage.h **** /** Copies the message into the given buffer. The buffer must be at least as large as msg_getNumHea
  65:source/HvMessage.h **** void msg_copyToBuffer(const HvMessage *m, char *buffer, hv_size_t len);
  66:source/HvMessage.h **** 
  67:source/HvMessage.h **** void msg_setElementToFrom(HvMessage *n, int indexN, const HvMessage *const m, int indexM);
  68:source/HvMessage.h **** 
  69:source/HvMessage.h **** /** Frees a message on the heap. Does nothing if argument is NULL. */
  70:source/HvMessage.h **** void msg_free(HvMessage *m);
  71:source/HvMessage.h **** 
  72:source/HvMessage.h **** HvMessage *msg_init(HvMessage *m, hv_size_t numElements, hv_uint32_t timestamp);
  73:source/HvMessage.h **** 
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 3


  74:source/HvMessage.h **** HvMessage *msg_initWithFloat(HvMessage *m, hv_uint32_t timestamp, float f);
  75:source/HvMessage.h **** 
  76:source/HvMessage.h **** HvMessage *msg_initWithBang(HvMessage *m, hv_uint32_t timestamp);
  77:source/HvMessage.h **** 
  78:source/HvMessage.h **** HvMessage *msg_initWithSymbol(HvMessage *m, hv_uint32_t timestamp, const char *s);
  79:source/HvMessage.h **** 
  80:source/HvMessage.h **** HvMessage *msg_initWithHash(HvMessage *m, hv_uint32_t timestamp, hv_uint32_t h);
  81:source/HvMessage.h **** 
  82:source/HvMessage.h **** static inline hv_uint32_t msg_getTimestamp(const HvMessage *m) {
  83:source/HvMessage.h ****   return m->timestamp;
  84:source/HvMessage.h **** }
  85:source/HvMessage.h **** 
  86:source/HvMessage.h **** static inline void msg_setTimestamp(HvMessage *m, hv_uint32_t timestamp) {
  87:source/HvMessage.h ****   m->timestamp = timestamp;
  88:source/HvMessage.h **** }
  89:source/HvMessage.h **** 
  90:source/HvMessage.h **** static inline int msg_getNumElements(const HvMessage *m) {
  91:source/HvMessage.h ****   return (int) m->numElements;
  92:source/HvMessage.h **** }
  93:source/HvMessage.h **** 
  94:source/HvMessage.h **** /** Returns the total number of bytes this message consumes in memory. */
  95:source/HvMessage.h **** static inline hv_uint32_t msg_getSize(const HvMessage *m) {
  96:source/HvMessage.h ****   return m->numBytes;
  97:source/HvMessage.h **** }
  98:source/HvMessage.h **** 
  99:source/HvMessage.h **** static inline ElementType msg_getType(const HvMessage *m, int index) {
 100:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 101:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 102:source/HvMessage.h **** }
 103:source/HvMessage.h **** 
 104:source/HvMessage.h **** static inline void msg_setBang(HvMessage *m, int index) {
 105:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 106:source/HvMessage.h ****   (&(m->elem)+index)->type = HV_MSG_BANG;
 107:source/HvMessage.h ****   (&(m->elem)+index)->data.s = NULL;
 108:source/HvMessage.h **** }
 109:source/HvMessage.h **** 
 110:source/HvMessage.h **** static inline bool msg_isBang(const HvMessage *m, int index) {
 111:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_BANG) : false;
 112:source/HvMessage.h **** }
 113:source/HvMessage.h **** 
 114:source/HvMessage.h **** static inline void msg_setFloat(HvMessage *m, int index, float f) {
 115:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 116:source/HvMessage.h ****   (&(m->elem)+index)->type = HV_MSG_FLOAT;
 117:source/HvMessage.h ****   (&(m->elem)+index)->data.f = f;
 118:source/HvMessage.h **** }
 119:source/HvMessage.h **** 
 120:source/HvMessage.h **** static inline float msg_getFloat(const HvMessage *const m, int index) {
  35              		.loc 1 120 21 view -0
  36              		.cfi_startproc
  37              		@ Volatile: function does not return.
  38              		@ args = 0, pretend = 0, frame = 0
  39              		@ frame_needed = 0, uses_anonymous_args = 0
  40              	.LVL0:
  41              		.loc 1 120 21 is_stmt 0 view .LVU1
  42 0000 08B5     		push	{r3, lr}
  43              		.cfi_def_cfa_offset 8
  44              		.cfi_offset 3, -8
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 4


  45              		.cfi_offset 14, -4
 121:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
  46              		.loc 1 121 3 view .LVU2
  47 0002 034A     		ldr	r2, .L4
  48 0004 7921     		movs	r1, #121
  49 0006 034B     		ldr	r3, .L4+4
  50 0008 0348     		ldr	r0, .L4+8
  51 000a FFF7FEFF 		bl	__assert_func
  52              	.LVL1:
  53              	.L5:
  54 000e 00BF     		.align	2
  55              	.L4:
  56 0010 00000000 		.word	.LANCHOR0
  57 0014 00000000 		.word	.LC0
  58 0018 20000000 		.word	.LC1
  59              		.cfi_endproc
  60              	.LFE409:
  62              		.section	.text.sVarf_init,"ax",%progbits
  63              		.align	1
  64              		.p2align 2,,3
  65              		.global	sVarf_init
  66              		.syntax unified
  67              		.thumb
  68              		.thumb_func
  70              	sVarf_init:
  71              	.LVL2:
  72              	.LFB404:
  73              		.file 2 "source/HvSignalVar.c"
   1:source/HvSignalVar.c **** /**
   2:source/HvSignalVar.c ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvSignalVar.c ****  *
   4:source/HvSignalVar.c ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvSignalVar.c ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvSignalVar.c ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvSignalVar.c ****  *
   8:source/HvSignalVar.c ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvSignalVar.c ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvSignalVar.c ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvSignalVar.c ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvSignalVar.c ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvSignalVar.c ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvSignalVar.c ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvSignalVar.c ****  */
  16:source/HvSignalVar.c **** 
  17:source/HvSignalVar.c **** #include "HvSignalVar.h"
  18:source/HvSignalVar.c **** 
  19:source/HvSignalVar.c **** // __var~f
  20:source/HvSignalVar.c **** 
  21:source/HvSignalVar.c **** static void sVarf_update(SignalVarf *o, float k, float step, bool reverse) {
  22:source/HvSignalVar.c **** #if HV_SIMD_AVX
  23:source/HvSignalVar.c ****   if (reverse) o->v = _mm256_setr_ps(k+7.0f*step, k+6.0f*step, k+5.0f*step, k+4.0f*step, k+3.0f*ste
  24:source/HvSignalVar.c ****   else o->v = _mm256_set_ps(k+7.0f*step, k+6.0f*step, k+5.0f*step, k+4.0f*step, k+3.0f*step, k+2.0f
  25:source/HvSignalVar.c **** #elif HV_SIMD_SSE
  26:source/HvSignalVar.c ****   if (reverse) o->v = _mm_setr_ps(k+3.0f*step, k+2.0f*step, k+step, k);
  27:source/HvSignalVar.c ****   else o->v = _mm_set_ps(k+3.0f*step, k+2.0f*step, k+step, k);
  28:source/HvSignalVar.c **** #elif HV_SIMD_NEON
  29:source/HvSignalVar.c ****   if (reverse) o->v = (float32x4_t) {3.0f*step+k, 2.0f*step+k, step+k, k};
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 5


  30:source/HvSignalVar.c ****   else o->v = (float32x4_t) {k, step+k, 2.0f*step+k, 3.0f*step+k};
  31:source/HvSignalVar.c **** #else // HV_SIMD_NONE
  32:source/HvSignalVar.c ****   o->v = k;
  33:source/HvSignalVar.c **** #endif
  34:source/HvSignalVar.c **** }
  35:source/HvSignalVar.c **** 
  36:source/HvSignalVar.c **** hv_size_t sVarf_init(SignalVarf *o, float k, float step, bool reverse) {
  74              		.loc 2 36 72 is_stmt 1 view -0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 0, uses_anonymous_args = 0
  78              		@ link register save eliminated.
  37:source/HvSignalVar.c ****   sVarf_update(o, k, step, reverse);
  79              		.loc 2 37 3 view .LVU4
  36:source/HvSignalVar.c ****   sVarf_update(o, k, step, reverse);
  80              		.loc 2 36 72 is_stmt 0 view .LVU5
  81 0000 0346     		mov	r3, r0
  82              	.LVL3:
  83              	.LBB38:
  84              	.LBI38:
  21:source/HvSignalVar.c **** #if HV_SIMD_AVX
  85              		.loc 2 21 13 is_stmt 1 view .LVU6
  86              	.LBB39:
  32:source/HvSignalVar.c **** #endif
  87              		.loc 2 32 3 view .LVU7
  88              	.LBE39:
  89              	.LBE38:
  38:source/HvSignalVar.c ****   return 0;
  39:source/HvSignalVar.c **** }
  90              		.loc 2 39 1 is_stmt 0 view .LVU8
  91 0002 0020     		movs	r0, #0
  92              	.LVL4:
  93              	.LBB41:
  94              	.LBB40:
  32:source/HvSignalVar.c **** #endif
  95              		.loc 2 32 8 view .LVU9
  96 0004 83ED000A 		vstr.32	s0, [r3]
  97              	.LVL5:
  32:source/HvSignalVar.c **** #endif
  98              		.loc 2 32 8 view .LVU10
  99              	.LBE40:
 100              	.LBE41:
  38:source/HvSignalVar.c ****   return 0;
 101              		.loc 2 38 3 is_stmt 1 view .LVU11
 102              		.loc 2 39 1 is_stmt 0 view .LVU12
 103 0008 7047     		bx	lr
 104              		.cfi_endproc
 105              	.LFE404:
 107 000a 00BF     		.section	.text.sVarf_onMessage,"ax",%progbits
 108              		.align	1
 109              		.p2align 2,,3
 110              		.global	sVarf_onMessage
 111              		.syntax unified
 112              		.thumb
 113              		.thumb_func
 115              	sVarf_onMessage:
 116              	.LVL6:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 6


 117              	.LFB405:
  40:source/HvSignalVar.c **** 
  41:source/HvSignalVar.c **** void sVarf_onMessage(HeavyContextInterface *_c, SignalVarf *o, const HvMessage *m) {
 118              		.loc 2 41 84 is_stmt 1 view -0
 119              		.cfi_startproc
 120              		@ args = 0, pretend = 0, frame = 0
 121              		@ frame_needed = 0, uses_anonymous_args = 0
 122              		@ link register save eliminated.
  42:source/HvSignalVar.c ****   if (msg_isFloat(m,0)) {
 123              		.loc 2 42 3 view .LVU14
 124              	.LBB66:
 125              	.LBI66:
 122:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 123:source/HvMessage.h **** }
 124:source/HvMessage.h **** 
 125:source/HvMessage.h **** static inline bool msg_isFloat(const HvMessage *const m, int index) {
 126              		.loc 1 125 20 view .LVU15
 127              	.LBB67:
 126:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_FLOAT) : false;
 128              		.loc 1 126 3 view .LVU16
 129              	.LBB68:
 130              	.LBI68:
  90:source/HvMessage.h ****   return (int) m->numElements;
 131              		.loc 1 90 19 view .LVU17
 132              	.LBB69:
  91:source/HvMessage.h **** }
 133              		.loc 1 91 3 view .LVU18
  91:source/HvMessage.h **** }
 134              		.loc 1 91 3 is_stmt 0 view .LVU19
 135              	.LBE69:
 136              	.LBE68:
 137              		.loc 1 126 83 view .LVU20
 138 0000 9388     		ldrh	r3, [r2, #4]
 139 0002 03B9     		cbnz	r3, .L13
 140              	.L7:
 141              	.LBE67:
 142              	.LBE66:
  43:source/HvSignalVar.c ****     sVarf_update(o, msg_getFloat(m,0), msg_isFloat(m,1) ? msg_getFloat(m,1) : 0.0f, msg_getNumEleme
  44:source/HvSignalVar.c ****   }
  45:source/HvSignalVar.c **** }
 143              		.loc 2 45 1 view .LVU21
 144 0004 7047     		bx	lr
 145              	.L13:
 146              	.LVL7:
 147              	.LBB76:
 148              	.LBB74:
 149              	.LBB70:
 150              	.LBI70:
  99:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 151              		.loc 1 99 27 is_stmt 1 view .LVU22
 152              	.LBB71:
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 153              		.loc 1 100 3 view .LVU23
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 154              		.loc 1 100 3 is_stmt 0 view .LVU24
 155              	.LBE71:
 156              	.LBE70:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 7


 157              	.LBE74:
 158              	.LBE76:
  91:source/HvMessage.h **** }
 159              		.loc 1 91 3 is_stmt 1 view .LVU25
 160              	.LBB77:
 161              	.LBB75:
 162              	.LBB73:
 163              	.LBB72:
 101:source/HvMessage.h **** }
 164              		.loc 1 101 3 view .LVU26
 101:source/HvMessage.h **** }
 165              		.loc 1 101 3 is_stmt 0 view .LVU27
 166              	.LBE72:
 167              	.LBE73:
 168              		.loc 1 126 83 view .LVU28
 169 0006 137A     		ldrb	r3, [r2, #8]	@ zero_extendqisi2
 170 0008 012B     		cmp	r3, #1
 171 000a FBD1     		bne	.L7
 172              	.LVL8:
 173              		.loc 1 126 83 view .LVU29
 174              	.LBE75:
 175              	.LBE77:
  43:source/HvSignalVar.c ****   }
 176              		.loc 2 43 5 is_stmt 1 view .LVU30
 177              	.LBB78:
 178              	.LBI78:
 120:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 179              		.loc 1 120 21 view .LVU31
 180              	.LBB79:
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 181              		.loc 1 121 3 view .LVU32
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 182              		.loc 1 121 3 is_stmt 0 view .LVU33
 183              	.LBE79:
 184              	.LBE78:
  91:source/HvMessage.h **** }
 185              		.loc 1 91 3 is_stmt 1 view .LVU34
 186              	.LBB81:
 187              	.LBB80:
 122:source/HvMessage.h **** }
 188              		.loc 1 122 3 view .LVU35
 122:source/HvMessage.h **** }
 189              		.loc 1 122 3 is_stmt 0 view .LVU36
 190              	.LBE80:
 191              	.LBE81:
 192              		.loc 1 126 3 is_stmt 1 view .LVU37
  91:source/HvMessage.h **** }
 193              		.loc 1 91 3 view .LVU38
  91:source/HvMessage.h **** }
 194              		.loc 1 91 3 view .LVU39
 195              	.LBB82:
 196              	.LBI82:
  21:source/HvSignalVar.c **** #if HV_SIMD_AVX
 197              		.loc 2 21 13 view .LVU40
 198              	.LBB83:
  32:source/HvSignalVar.c **** #endif
 199              		.loc 2 32 3 view .LVU41
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 8


  32:source/HvSignalVar.c **** #endif
 200              		.loc 2 32 8 is_stmt 0 view .LVU42
 201 000c D368     		ldr	r3, [r2, #12]	@ float
 202 000e 0B60     		str	r3, [r1]	@ float
 203              	.LBE83:
 204              	.LBE82:
 205              		.loc 2 45 1 view .LVU43
 206 0010 7047     		bx	lr
 207              		.cfi_endproc
 208              	.LFE405:
 210 0012 00BF     		.section	.text.sVari_init,"ax",%progbits
 211              		.align	1
 212              		.p2align 2,,3
 213              		.global	sVari_init
 214              		.syntax unified
 215              		.thumb
 216              		.thumb_func
 218              	sVari_init:
 219              	.LVL9:
 220              	.LFB407:
  46:source/HvSignalVar.c **** 
  47:source/HvSignalVar.c **** 
  48:source/HvSignalVar.c **** 
  49:source/HvSignalVar.c **** // __var~i
  50:source/HvSignalVar.c **** 
  51:source/HvSignalVar.c **** static void sVari_update(SignalVari *o, int k, int step, bool reverse) {
  52:source/HvSignalVar.c **** #if HV_SIMD_AVX
  53:source/HvSignalVar.c ****   if (reverse) o->v = _mm256_setr_epi32(k+7*step, k+6*step, k+5*step, k+4*step, k+3*step, k+2*step,
  54:source/HvSignalVar.c ****   else o->v = _mm256_set_epi32(k+7*step, k+6*step, k+5*step, k+4*step, k+3*step, k+2*step, k+step, 
  55:source/HvSignalVar.c **** #elif HV_SIMD_SSE
  56:source/HvSignalVar.c ****   if (reverse) o->v = _mm_setr_epi32(k+3*step, k+2*step, k+step, k);
  57:source/HvSignalVar.c ****   else o->v = _mm_set_epi32(k+3*step, k+2*step, k+step, k);
  58:source/HvSignalVar.c **** #elif HV_SIMD_NEON
  59:source/HvSignalVar.c ****   if (reverse) o->v = (int32x4_t) {3*step+k, 2*step+k, step+k, k};
  60:source/HvSignalVar.c ****   else o->v = (int32x4_t) {k, step+k, 2*step+k, 3*step+k};
  61:source/HvSignalVar.c **** #else // HV_SIMD_NEON
  62:source/HvSignalVar.c ****   o->v = k;
  63:source/HvSignalVar.c **** #endif
  64:source/HvSignalVar.c **** }
  65:source/HvSignalVar.c **** 
  66:source/HvSignalVar.c **** hv_size_t sVari_init(SignalVari *o, int k, int step, bool reverse) {
 221              		.loc 2 66 68 is_stmt 1 view -0
 222              		.cfi_startproc
 223              		@ args = 0, pretend = 0, frame = 0
 224              		@ frame_needed = 0, uses_anonymous_args = 0
 225              		@ link register save eliminated.
  67:source/HvSignalVar.c ****   sVari_update(o, k, step, reverse);
 226              		.loc 2 67 3 view .LVU45
  66:source/HvSignalVar.c ****   sVari_update(o, k, step, reverse);
 227              		.loc 2 66 68 is_stmt 0 view .LVU46
 228 0000 0346     		mov	r3, r0
 229              	.LVL10:
 230              	.LBB84:
 231              	.LBI84:
  51:source/HvSignalVar.c **** #if HV_SIMD_AVX
 232              		.loc 2 51 13 is_stmt 1 view .LVU47
 233              	.LBB85:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 9


  62:source/HvSignalVar.c **** #endif
 234              		.loc 2 62 3 view .LVU48
 235              	.LBE85:
 236              	.LBE84:
  68:source/HvSignalVar.c ****   return 0;
  69:source/HvSignalVar.c **** }
 237              		.loc 2 69 1 is_stmt 0 view .LVU49
 238 0002 0020     		movs	r0, #0
 239              	.LVL11:
 240              	.LBB87:
 241              	.LBB86:
  62:source/HvSignalVar.c **** #endif
 242              		.loc 2 62 8 view .LVU50
 243 0004 1960     		str	r1, [r3]
 244              	.LVL12:
  62:source/HvSignalVar.c **** #endif
 245              		.loc 2 62 8 view .LVU51
 246              	.LBE86:
 247              	.LBE87:
  68:source/HvSignalVar.c ****   return 0;
 248              		.loc 2 68 3 is_stmt 1 view .LVU52
 249              		.loc 2 69 1 is_stmt 0 view .LVU53
 250 0006 7047     		bx	lr
 251              		.cfi_endproc
 252              	.LFE407:
 254              		.section	.text.sVari_onMessage,"ax",%progbits
 255              		.align	1
 256              		.p2align 2,,3
 257              		.global	sVari_onMessage
 258              		.syntax unified
 259              		.thumb
 260              		.thumb_func
 262              	sVari_onMessage:
 263              	.LVL13:
 264              	.LFB408:
  70:source/HvSignalVar.c **** 
  71:source/HvSignalVar.c **** void sVari_onMessage(HeavyContextInterface *_c, SignalVari *o, const HvMessage *m) {
 265              		.loc 2 71 84 is_stmt 1 view -0
 266              		.cfi_startproc
 267              		@ args = 0, pretend = 0, frame = 0
 268              		@ frame_needed = 0, uses_anonymous_args = 0
 269              		@ link register save eliminated.
  72:source/HvSignalVar.c ****   if (msg_isFloat(m,0)) {
 270              		.loc 2 72 3 view .LVU55
 271              	.LBB112:
 272              	.LBI112:
 125:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_FLOAT) : false;
 273              		.loc 1 125 20 view .LVU56
 274              	.LBB113:
 275              		.loc 1 126 3 view .LVU57
 276              	.LBB114:
 277              	.LBI114:
  90:source/HvMessage.h ****   return (int) m->numElements;
 278              		.loc 1 90 19 view .LVU58
 279              	.LBB115:
  91:source/HvMessage.h **** }
 280              		.loc 1 91 3 view .LVU59
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 10


  91:source/HvMessage.h **** }
 281              		.loc 1 91 3 is_stmt 0 view .LVU60
 282              	.LBE115:
 283              	.LBE114:
 284              		.loc 1 126 83 view .LVU61
 285 0000 9388     		ldrh	r3, [r2, #4]
 286 0002 03B9     		cbnz	r3, .L21
 287              	.L15:
 288              	.LBE113:
 289              	.LBE112:
  73:source/HvSignalVar.c ****     sVari_update(o, (int) msg_getFloat(m,0), msg_isFloat(m,1) ? (int) msg_getFloat(m,1) : 0, msg_ge
  74:source/HvSignalVar.c ****   }
  75:source/HvSignalVar.c **** }
 290              		.loc 2 75 1 view .LVU62
 291 0004 7047     		bx	lr
 292              	.L21:
 293              	.LVL14:
 294              	.LBB122:
 295              	.LBB120:
 296              	.LBB116:
 297              	.LBI116:
  99:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 298              		.loc 1 99 27 is_stmt 1 view .LVU63
 299              	.LBB117:
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 300              		.loc 1 100 3 view .LVU64
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 301              		.loc 1 100 3 is_stmt 0 view .LVU65
 302              	.LBE117:
 303              	.LBE116:
 304              	.LBE120:
 305              	.LBE122:
  91:source/HvMessage.h **** }
 306              		.loc 1 91 3 is_stmt 1 view .LVU66
 307              	.LBB123:
 308              	.LBB121:
 309              	.LBB119:
 310              	.LBB118:
 101:source/HvMessage.h **** }
 311              		.loc 1 101 3 view .LVU67
 101:source/HvMessage.h **** }
 312              		.loc 1 101 3 is_stmt 0 view .LVU68
 313              	.LBE118:
 314              	.LBE119:
 315              		.loc 1 126 83 view .LVU69
 316 0006 137A     		ldrb	r3, [r2, #8]	@ zero_extendqisi2
 317 0008 012B     		cmp	r3, #1
 318 000a FBD1     		bne	.L15
 319              	.LVL15:
 320              		.loc 1 126 83 view .LVU70
 321              	.LBE121:
 322              	.LBE123:
  73:source/HvSignalVar.c ****   }
 323              		.loc 2 73 5 is_stmt 1 view .LVU71
 324              	.LBB124:
 325              	.LBI124:
 120:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 11


 326              		.loc 1 120 21 view .LVU72
 327              	.LBB125:
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 328              		.loc 1 121 3 view .LVU73
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 329              		.loc 1 121 3 is_stmt 0 view .LVU74
 330              	.LBE125:
 331              	.LBE124:
  91:source/HvMessage.h **** }
 332              		.loc 1 91 3 is_stmt 1 view .LVU75
 333              	.LBB127:
 334              	.LBB126:
 122:source/HvMessage.h **** }
 335              		.loc 1 122 3 view .LVU76
 122:source/HvMessage.h **** }
 336              		.loc 1 122 3 is_stmt 0 view .LVU77
 337              	.LBE126:
 338              	.LBE127:
 339              		.loc 1 126 3 is_stmt 1 view .LVU78
  91:source/HvMessage.h **** }
 340              		.loc 1 91 3 view .LVU79
  91:source/HvMessage.h **** }
 341              		.loc 1 91 3 view .LVU80
 342              	.LBB128:
 343              	.LBI128:
  51:source/HvSignalVar.c **** #if HV_SIMD_AVX
 344              		.loc 2 51 13 view .LVU81
 345              	.LBB129:
  62:source/HvSignalVar.c **** #endif
 346              		.loc 2 62 3 view .LVU82
 347              	.LBE129:
 348              	.LBE128:
  73:source/HvSignalVar.c ****   }
 349              		.loc 2 73 5 is_stmt 0 view .LVU83
 350 000c D2ED037A 		vldr.32	s15, [r2, #12]
 351 0010 FDEEE77A 		vcvt.s32.f32	s15, s15
 352 0014 C1ED007A 		vstr.32	s15, [r1]	@ int
 353              		.loc 2 75 1 view .LVU84
 354 0018 7047     		bx	lr
 355              		.cfi_endproc
 356              	.LFE408:
 358 001a 00BF     		.section	.rodata.__func__.0,"a"
 359              		.align	2
 360              		.set	.LANCHOR0,. + 0
 363              	__func__.0:
 364 0000 6D73675F 		.ascii	"msg_getFloat\000"
 364      67657446 
 364      6C6F6174 
 364      00
 365              		.text
 366              	.Letext0:
 367              		.file 3 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/machine/_default_types.h"
 368              		.file 4 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/sys/_stdint.h"
 369              		.file 5 "/Library/DaisyToolchain/0.2.0/arm/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 370              		.file 6 "source/HvHeavy.h"
 371              		.file 7 "source/HvSignalVar.h"
 372              		.file 8 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/assert.h"
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 12


ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s 			page 13


DEFINED SYMBOLS
                            *ABS*:0000000000000000 HvSignalVar.c
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:19     .rodata.msg_getFloat.part.0.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:26     .text.msg_getFloat.part.0:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:32     .text.msg_getFloat.part.0:0000000000000000 msg_getFloat.part.0
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:56     .text.msg_getFloat.part.0:0000000000000010 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:63     .text.sVarf_init:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:70     .text.sVarf_init:0000000000000000 sVarf_init
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:108    .text.sVarf_onMessage:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:115    .text.sVarf_onMessage:0000000000000000 sVarf_onMessage
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:211    .text.sVari_init:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:218    .text.sVari_init:0000000000000000 sVari_init
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:255    .text.sVari_onMessage:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:262    .text.sVari_onMessage:0000000000000000 sVari_onMessage
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:359    .rodata.__func__.0:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//cc33RQPT.s:363    .rodata.__func__.0:0000000000000000 __func__.0

UNDEFINED SYMBOLS
__assert_func
