ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 1


   1              		.cpu cortex-m7
   2              		.arch armv7e-m
   3              		.fpu fpv5-d16
   4              		.eabi_attribute 28, 1
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 2
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.file	"HvMessagePool.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata.ml_push.part.0.str1.4,"aMS",%progbits,1
  19              		.align	2
  20              	.LC0:
  21 0000 6E20213D 		.ascii	"n != ((void *)0)\000"
  21      20282876 
  21      6F696420 
  21      2A293029 
  21      00
  22 0011 000000   		.align	2
  23              	.LC1:
  24 0014 736F7572 		.ascii	"source/HvMessagePool.c\000"
  24      63652F48 
  24      764D6573 
  24      73616765 
  24      506F6F6C 
  25              		.section	.text.ml_push.part.0,"ax",%progbits
  26              		.align	1
  27              		.p2align 2,,3
  28              		.syntax unified
  29              		.thumb
  30              		.thumb_func
  32              	ml_push.part.0:
  33              	.LFB354:
  34              		.file 1 "source/HvMessagePool.c"
   1:source/HvMessagePool.c **** /**
   2:source/HvMessagePool.c ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvMessagePool.c ****  *
   4:source/HvMessagePool.c ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvMessagePool.c ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvMessagePool.c ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvMessagePool.c ****  *
   8:source/HvMessagePool.c ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvMessagePool.c ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvMessagePool.c ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvMessagePool.c ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvMessagePool.c ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvMessagePool.c ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvMessagePool.c ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvMessagePool.c ****  */
  16:source/HvMessagePool.c **** 
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 2


  17:source/HvMessagePool.c **** #include "HvMessagePool.h"
  18:source/HvMessagePool.c **** #include "HvMessage.h"
  19:source/HvMessagePool.c **** 
  20:source/HvMessagePool.c **** // the number of bytes reserved at a time from the pool
  21:source/HvMessagePool.c **** #define MP_BLOCK_SIZE_BYTES 512
  22:source/HvMessagePool.c **** 
  23:source/HvMessagePool.c **** #if HV_APPLE
  24:source/HvMessagePool.c **** #pragma mark - MessageList
  25:source/HvMessagePool.c **** #endif
  26:source/HvMessagePool.c **** 
  27:source/HvMessagePool.c **** typedef struct MessageListNode {
  28:source/HvMessagePool.c ****   char *p;
  29:source/HvMessagePool.c ****   struct MessageListNode *next;
  30:source/HvMessagePool.c **** } MessageListNode;
  31:source/HvMessagePool.c **** 
  32:source/HvMessagePool.c **** static inline bool ml_hasAvailable(HvMessagePoolList *ml) {
  33:source/HvMessagePool.c ****   return (ml->head != NULL);
  34:source/HvMessagePool.c **** }
  35:source/HvMessagePool.c **** 
  36:source/HvMessagePool.c **** static char *ml_pop(HvMessagePoolList *ml) {
  37:source/HvMessagePool.c ****   MessageListNode *n = ml->head;
  38:source/HvMessagePool.c ****   ml->head = n->next;
  39:source/HvMessagePool.c ****   n->next = ml->pool;
  40:source/HvMessagePool.c ****   ml->pool = n;
  41:source/HvMessagePool.c ****   char *const p = n->p;
  42:source/HvMessagePool.c ****   n->p = NULL; // set to NULL to make it clear that this node does not have a valid buffer
  43:source/HvMessagePool.c ****   return p;
  44:source/HvMessagePool.c **** }
  45:source/HvMessagePool.c **** 
  46:source/HvMessagePool.c **** /** Push a MessageListNode with the given pointer onto the head of the queue. */
  47:source/HvMessagePool.c **** static void ml_push(HvMessagePoolList *ml, void *p) {
  35              		.loc 1 47 13 view -0
  36              		.cfi_startproc
  37              		@ Volatile: function does not return.
  38              		@ args = 0, pretend = 0, frame = 0
  39              		@ frame_needed = 0, uses_anonymous_args = 0
  40              	.LVL0:
  41              		.loc 1 47 13 is_stmt 0 view .LVU1
  42 0000 08B5     		push	{r3, lr}
  43              		.cfi_def_cfa_offset 8
  44              		.cfi_offset 3, -8
  45              		.cfi_offset 14, -4
  48:source/HvMessagePool.c ****   MessageListNode *n = NULL;
  49:source/HvMessagePool.c ****   if (ml->pool != NULL) {
  50:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
  51:source/HvMessagePool.c ****     n = ml->pool;
  52:source/HvMessagePool.c ****     ml->pool = n->next;
  53:source/HvMessagePool.c ****   } else {
  54:source/HvMessagePool.c ****     // a MessageListNode is not available, allocate one
  55:source/HvMessagePool.c ****     n = (MessageListNode *) hv_malloc(sizeof(MessageListNode));
  56:source/HvMessagePool.c ****     hv_assert(n != NULL);
  46              		.loc 1 56 5 view .LVU2
  47 0002 034A     		ldr	r2, .L4
  48 0004 3821     		movs	r1, #56
  49 0006 034B     		ldr	r3, .L4+4
  50 0008 0348     		ldr	r0, .L4+8
  51 000a FFF7FEFF 		bl	__assert_func
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 3


  52              	.LVL1:
  53              	.L5:
  54 000e 00BF     		.align	2
  55              	.L4:
  56 0010 00000000 		.word	.LANCHOR0
  57 0014 00000000 		.word	.LC0
  58 0018 14000000 		.word	.LC1
  59              		.cfi_endproc
  60              	.LFE354:
  62              		.section	.rodata.mp_init.str1.4,"aMS",%progbits,1
  63              		.align	2
  64              	.LC2:
  65 0000 6D702D3E 		.ascii	"mp->buffer != ((void *)0)\000"
  65      62756666 
  65      65722021 
  65      3D202828 
  65      766F6964 
  66              		.section	.text.mp_init,"ax",%progbits
  67              		.align	1
  68              		.p2align 2,,3
  69              		.global	mp_init
  70              		.syntax unified
  71              		.thumb
  72              		.thumb_func
  74              	mp_init:
  75              	.LVL2:
  76              	.LFB350:
  57:source/HvMessagePool.c ****   }
  58:source/HvMessagePool.c ****   n->p = (char *) p;
  59:source/HvMessagePool.c ****   n->next = ml->head;
  60:source/HvMessagePool.c ****   ml->head = n; // push to the front of the queue
  61:source/HvMessagePool.c **** }
  62:source/HvMessagePool.c **** 
  63:source/HvMessagePool.c **** static void ml_free(HvMessagePoolList *ml) {
  64:source/HvMessagePool.c ****   if (ml != NULL) {
  65:source/HvMessagePool.c ****     while (ml_hasAvailable(ml)) {
  66:source/HvMessagePool.c ****       ml_pop(ml);
  67:source/HvMessagePool.c ****     }
  68:source/HvMessagePool.c ****     while (ml->pool != NULL) {
  69:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
  70:source/HvMessagePool.c ****       ml->pool = n->next;
  71:source/HvMessagePool.c ****       hv_free(n);
  72:source/HvMessagePool.c ****     }
  73:source/HvMessagePool.c ****   }
  74:source/HvMessagePool.c **** }
  75:source/HvMessagePool.c **** 
  76:source/HvMessagePool.c **** #if HV_APPLE
  77:source/HvMessagePool.c **** #pragma mark - HvMessagePool
  78:source/HvMessagePool.c **** #endif
  79:source/HvMessagePool.c **** 
  80:source/HvMessagePool.c **** static hv_size_t mp_messagelistIndexForSize(hv_size_t byteSize) {
  81:source/HvMessagePool.c ****   return (hv_size_t) hv_max_i((hv_min_max_log2((hv_uint32_t) byteSize) - 5), 0);
  82:source/HvMessagePool.c **** }
  83:source/HvMessagePool.c **** 
  84:source/HvMessagePool.c **** hv_size_t mp_init(HvMessagePool *mp, hv_size_t numKB) {
  77              		.loc 1 84 55 is_stmt 1 view -0
  78              		.cfi_startproc
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 4


  79              		@ args = 0, pretend = 0, frame = 0
  80              		@ frame_needed = 0, uses_anonymous_args = 0
  85:source/HvMessagePool.c ****   mp->bufferSize = numKB * 1024;
  81              		.loc 1 85 3 view .LVU4
  84:source/HvMessagePool.c ****   mp->bufferSize = numKB * 1024;
  82              		.loc 1 84 55 is_stmt 0 view .LVU5
  83 0000 38B5     		push	{r3, r4, r5, lr}
  84              		.cfi_def_cfa_offset 16
  85              		.cfi_offset 3, -16
  86              		.cfi_offset 4, -12
  87              		.cfi_offset 5, -8
  88              		.cfi_offset 14, -4
  84:source/HvMessagePool.c ****   mp->bufferSize = numKB * 1024;
  89              		.loc 1 84 55 view .LVU6
  90 0002 0446     		mov	r4, r0
  91              		.loc 1 85 26 view .LVU7
  92 0004 8D02     		lsls	r5, r1, #10
  86:source/HvMessagePool.c ****   mp->buffer = (char *) hv_malloc(mp->bufferSize);
  93              		.loc 1 86 25 view .LVU8
  94 0006 2846     		mov	r0, r5
  95              	.LVL3:
  85:source/HvMessagePool.c ****   mp->bufferSize = numKB * 1024;
  96              		.loc 1 85 18 view .LVU9
  97 0008 6560     		str	r5, [r4, #4]
  98              		.loc 1 86 3 is_stmt 1 view .LVU10
  99              		.loc 1 86 25 is_stmt 0 view .LVU11
 100 000a FFF7FEFF 		bl	malloc
 101              	.LVL4:
 102              		.loc 1 86 14 view .LVU12
 103 000e 2060     		str	r0, [r4]
  87:source/HvMessagePool.c ****   hv_assert(mp->buffer != NULL);
 104              		.loc 1 87 3 is_stmt 1 view .LVU13
 105 0010 58B1     		cbz	r0, .L9
  88:source/HvMessagePool.c ****   mp->bufferIndex = 0;
 106              		.loc 1 88 3 view .LVU14
 107              		.loc 1 88 19 is_stmt 0 view .LVU15
 108 0012 0023     		movs	r3, #0
  89:source/HvMessagePool.c **** 
  90:source/HvMessagePool.c ****   // initialise all message lists
  91:source/HvMessagePool.c ****   for (int i = 0; i < MP_NUM_MESSAGE_LISTS; i++) {
  92:source/HvMessagePool.c ****     mp->lists[i].head = NULL;
  93:source/HvMessagePool.c ****     mp->lists[i].pool = NULL;
  94:source/HvMessagePool.c ****   }
  95:source/HvMessagePool.c **** 
  96:source/HvMessagePool.c ****   return mp->bufferSize;
  97:source/HvMessagePool.c **** }
 109              		.loc 1 97 1 view .LVU16
 110 0014 2846     		mov	r0, r5
 111              	.LBB36:
  92:source/HvMessagePool.c ****     mp->lists[i].pool = NULL;
 112              		.loc 1 92 23 view .LVU17
 113 0016 C4E90233 		strd	r3, r3, [r4, #8]
  93:source/HvMessagePool.c ****   }
 114              		.loc 1 93 5 is_stmt 1 view .LVU18
  92:source/HvMessagePool.c ****     mp->lists[i].pool = NULL;
 115              		.loc 1 92 23 is_stmt 0 view .LVU19
 116 001a C4E90433 		strd	r3, r3, [r4, #16]
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 5


  93:source/HvMessagePool.c ****   }
 117              		.loc 1 93 5 is_stmt 1 view .LVU20
  92:source/HvMessagePool.c ****     mp->lists[i].pool = NULL;
 118              		.loc 1 92 23 is_stmt 0 view .LVU21
 119 001e C4E90633 		strd	r3, r3, [r4, #24]
  93:source/HvMessagePool.c ****   }
 120              		.loc 1 93 5 is_stmt 1 view .LVU22
  92:source/HvMessagePool.c ****     mp->lists[i].pool = NULL;
 121              		.loc 1 92 23 is_stmt 0 view .LVU23
 122 0022 C4E90833 		strd	r3, r3, [r4, #32]
  93:source/HvMessagePool.c ****   }
 123              		.loc 1 93 5 is_stmt 1 view .LVU24
  93:source/HvMessagePool.c ****   }
 124              		.loc 1 93 23 is_stmt 0 view .LVU25
 125 0026 A362     		str	r3, [r4, #40]
  91:source/HvMessagePool.c ****     mp->lists[i].head = NULL;
 126              		.loc 1 91 45 is_stmt 1 view .LVU26
 127              	.LVL5:
  91:source/HvMessagePool.c ****     mp->lists[i].head = NULL;
 128              		.loc 1 91 19 view .LVU27
 129              	.LBE36:
  96:source/HvMessagePool.c **** }
 130              		.loc 1 96 3 view .LVU28
 131              		.loc 1 97 1 is_stmt 0 view .LVU29
 132 0028 38BD     		pop	{r3, r4, r5, pc}
 133              	.LVL6:
 134              	.L9:
  87:source/HvMessagePool.c ****   mp->bufferIndex = 0;
 135              		.loc 1 87 3 discriminator 1 view .LVU30
 136 002a 034B     		ldr	r3, .L10
 137 002c 5721     		movs	r1, #87
 138 002e 034A     		ldr	r2, .L10+4
 139 0030 0348     		ldr	r0, .L10+8
 140 0032 FFF7FEFF 		bl	__assert_func
 141              	.LVL7:
 142              	.L11:
 143 0036 00BF     		.align	2
 144              	.L10:
 145 0038 00000000 		.word	.LC2
 146 003c 00000000 		.word	.LANCHOR1
 147 0040 14000000 		.word	.LC1
 148              		.cfi_endproc
 149              	.LFE350:
 151              		.section	.text.mp_free,"ax",%progbits
 152              		.align	1
 153              		.p2align 2,,3
 154              		.global	mp_free
 155              		.syntax unified
 156              		.thumb
 157              		.thumb_func
 159              	mp_free:
 160              	.LVL8:
 161              	.LFB351:
  98:source/HvMessagePool.c **** 
  99:source/HvMessagePool.c **** void mp_free(HvMessagePool *mp) {
 162              		.loc 1 99 33 is_stmt 1 view -0
 163              		.cfi_startproc
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 6


 164              		@ args = 0, pretend = 0, frame = 0
 165              		@ frame_needed = 0, uses_anonymous_args = 0
 100:source/HvMessagePool.c ****   hv_free(mp->buffer);
 166              		.loc 1 100 3 view .LVU32
  99:source/HvMessagePool.c ****   hv_free(mp->buffer);
 167              		.loc 1 99 33 is_stmt 0 view .LVU33
 168 0000 70B5     		push	{r4, r5, r6, lr}
 169              		.cfi_def_cfa_offset 16
 170              		.cfi_offset 4, -16
 171              		.cfi_offset 5, -12
 172              		.cfi_offset 6, -8
 173              		.cfi_offset 14, -4
 174 0002 0446     		mov	r4, r0
 175              	.LBB45:
 176              	.LBB46:
 177              	.LBB47:
 178              	.LBB48:
 179              	.LBB49:
  42:source/HvMessagePool.c ****   return p;
 180              		.loc 1 42 8 view .LVU34
 181 0004 0025     		movs	r5, #0
 182              	.LBE49:
 183              	.LBE48:
 184              	.LBE47:
 185              	.LBE46:
 186              	.LBE45:
 187              		.loc 1 100 3 view .LVU35
 188 0006 0068     		ldr	r0, [r0]
 189              	.LVL9:
 190              		.loc 1 100 3 view .LVU36
 191 0008 04F12006 		add	r6, r4, #32
 192 000c FFF7FEFF 		bl	free
 193              	.LVL10:
 101:source/HvMessagePool.c ****   for (int i = 0; i < MP_NUM_MESSAGE_LISTS; i++) {
 194              		.loc 1 101 3 is_stmt 1 view .LVU37
 195              	.LBB61:
 196              		.loc 1 101 8 view .LVU38
 197              		.loc 1 101 19 view .LVU39
 198              	.L18:
 102:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
 199              		.loc 1 102 5 discriminator 3 view .LVU40
 200              	.LBB59:
 201              	.LBI46:
  63:source/HvMessagePool.c ****   if (ml != NULL) {
 202              		.loc 1 63 13 discriminator 3 view .LVU41
 203              	.LBB57:
  64:source/HvMessagePool.c ****     while (ml_hasAvailable(ml)) {
 204              		.loc 1 64 3 discriminator 3 view .LVU42
  65:source/HvMessagePool.c ****       ml_pop(ml);
 205              		.loc 1 65 11 discriminator 3 view .LVU43
 206              	.LBB51:
 207              	.LBI51:
  32:source/HvMessagePool.c ****   return (ml->head != NULL);
 208              		.loc 1 32 20 discriminator 3 view .LVU44
 209              	.LBB52:
  33:source/HvMessagePool.c **** }
 210              		.loc 1 33 3 discriminator 3 view .LVU45
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 7


  33:source/HvMessagePool.c **** }
 211              		.loc 1 33 13 is_stmt 0 discriminator 3 view .LVU46
 212 0010 E068     		ldr	r0, [r4, #12]
  33:source/HvMessagePool.c **** }
 213              		.loc 1 33 13 discriminator 3 view .LVU47
 214              	.LBE52:
 215              	.LBE51:
  65:source/HvMessagePool.c ****       ml_pop(ml);
 216              		.loc 1 65 11 discriminator 3 view .LVU48
 217 0012 A8B1     		cbz	r0, .L13
 218 0014 2369     		ldr	r3, [r4, #16]
 219 0016 01E0     		b	.L14
 220              	.L20:
 221 0018 0346     		mov	r3, r0
 222 001a 1046     		mov	r0, r2
 223              	.L14:
  66:source/HvMessagePool.c ****     }
 224              		.loc 1 66 7 is_stmt 1 view .LVU49
 225              	.LVL11:
 226              	.LBB54:
 227              	.LBI48:
  36:source/HvMessagePool.c ****   MessageListNode *n = ml->head;
 228              		.loc 1 36 14 view .LVU50
 229              	.LBB50:
  37:source/HvMessagePool.c ****   ml->head = n->next;
 230              		.loc 1 37 3 view .LVU51
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 231              		.loc 1 38 3 view .LVU52
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 232              		.loc 1 38 15 is_stmt 0 view .LVU53
 233 001c 4268     		ldr	r2, [r0, #4]
  39:source/HvMessagePool.c ****   ml->pool = n;
 234              		.loc 1 39 3 is_stmt 1 view .LVU54
  39:source/HvMessagePool.c ****   ml->pool = n;
 235              		.loc 1 39 11 is_stmt 0 view .LVU55
 236 001e C0E90053 		strd	r5, r3, [r0]
  40:source/HvMessagePool.c ****   char *const p = n->p;
 237              		.loc 1 40 3 is_stmt 1 view .LVU56
  41:source/HvMessagePool.c ****   n->p = NULL; // set to NULL to make it clear that this node does not have a valid buffer
 238              		.loc 1 41 3 view .LVU57
 239              	.LVL12:
  42:source/HvMessagePool.c ****   return p;
 240              		.loc 1 42 3 view .LVU58
  43:source/HvMessagePool.c **** }
 241              		.loc 1 43 3 view .LVU59
  43:source/HvMessagePool.c **** }
 242              		.loc 1 43 3 is_stmt 0 view .LVU60
 243              	.LBE50:
 244              	.LBE54:
  65:source/HvMessagePool.c ****       ml_pop(ml);
 245              		.loc 1 65 11 is_stmt 1 view .LVU61
 246              	.LBB55:
  32:source/HvMessagePool.c ****   return (ml->head != NULL);
 247              		.loc 1 32 20 view .LVU62
 248              	.LBB53:
  33:source/HvMessagePool.c **** }
 249              		.loc 1 33 3 view .LVU63
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 8


  33:source/HvMessagePool.c **** }
 250              		.loc 1 33 3 is_stmt 0 view .LVU64
 251              	.LBE53:
 252              	.LBE55:
  65:source/HvMessagePool.c ****       ml_pop(ml);
 253              		.loc 1 65 11 view .LVU65
 254 0022 002A     		cmp	r2, #0
 255 0024 F8D1     		bne	.L20
 256 0026 E260     		str	r2, [r4, #12]
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 257              		.loc 1 68 11 is_stmt 1 view .LVU66
 258 0028 00E0     		b	.L17
 259              	.L31:
 260              	.LBB56:
  70:source/HvMessagePool.c ****       hv_free(n);
 261              		.loc 1 70 19 is_stmt 0 view .LVU67
 262 002a 4368     		ldr	r3, [r0, #4]
 263              	.L17:
  69:source/HvMessagePool.c ****       ml->pool = n->next;
 264              		.loc 1 69 7 is_stmt 1 view .LVU68
 265              	.LVL13:
  70:source/HvMessagePool.c ****       hv_free(n);
 266              		.loc 1 70 7 view .LVU69
  70:source/HvMessagePool.c ****       hv_free(n);
 267              		.loc 1 70 16 is_stmt 0 view .LVU70
 268 002c 2361     		str	r3, [r4, #16]
  71:source/HvMessagePool.c ****     }
 269              		.loc 1 71 7 is_stmt 1 view .LVU71
 270 002e FFF7FEFF 		bl	free
 271              	.LVL14:
  71:source/HvMessagePool.c ****     }
 272              		.loc 1 71 7 is_stmt 0 view .LVU72
 273              	.LBE56:
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 274              		.loc 1 68 11 is_stmt 1 view .LVU73
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 275              		.loc 1 68 14 is_stmt 0 view .LVU74
 276 0032 2069     		ldr	r0, [r4, #16]
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 277              		.loc 1 68 11 view .LVU75
 278 0034 0028     		cmp	r0, #0
 279 0036 F8D1     		bne	.L31
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 280              		.loc 1 68 11 view .LVU76
 281              	.LBE57:
 282              	.LBE59:
 101:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
 283              		.loc 1 101 45 is_stmt 1 view .LVU77
 101:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
 284              		.loc 1 101 19 view .LVU78
 101:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
 285              		.loc 1 101 3 is_stmt 0 view .LVU79
 286 0038 0834     		adds	r4, r4, #8
 287 003a B442     		cmp	r4, r6
 288 003c E8D1     		bne	.L18
 289              	.L33:
 101:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 9


 290              		.loc 1 101 3 view .LVU80
 291              	.LBE61:
 103:source/HvMessagePool.c ****   }
 104:source/HvMessagePool.c **** }
 292              		.loc 1 104 1 view .LVU81
 293 003e 70BD     		pop	{r4, r5, r6, pc}
 294              	.LVL15:
 295              	.L13:
 296              	.LBB62:
 297              	.LBB60:
 298              	.LBB58:
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 299              		.loc 1 68 11 is_stmt 1 view .LVU82
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 300              		.loc 1 68 14 is_stmt 0 view .LVU83
 301 0040 2069     		ldr	r0, [r4, #16]
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 302              		.loc 1 68 11 view .LVU84
 303 0042 0028     		cmp	r0, #0
 304 0044 F1D1     		bne	.L31
  68:source/HvMessagePool.c ****       MessageListNode *n = ml->pool;
 305              		.loc 1 68 11 view .LVU85
 306              	.LBE58:
 307              	.LBE60:
 101:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
 308              		.loc 1 101 45 is_stmt 1 view .LVU86
 101:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
 309              		.loc 1 101 19 view .LVU87
 101:source/HvMessagePool.c ****     ml_free(&mp->lists[i]);
 310              		.loc 1 101 3 is_stmt 0 view .LVU88
 311 0046 0834     		adds	r4, r4, #8
 312 0048 B442     		cmp	r4, r6
 313 004a E1D1     		bne	.L18
 314 004c F7E7     		b	.L33
 315              	.LBE62:
 316              		.cfi_endproc
 317              	.LFE351:
 319 004e 00BF     		.section	.text.mp_freeMessage,"ax",%progbits
 320              		.align	1
 321              		.p2align 2,,3
 322              		.global	mp_freeMessage
 323              		.syntax unified
 324              		.thumb
 325              		.thumb_func
 327              	mp_freeMessage:
 328              	.LVL16:
 329              	.LFB352:
 105:source/HvMessagePool.c **** 
 106:source/HvMessagePool.c **** void mp_freeMessage(HvMessagePool *mp, HvMessage *m) {
 330              		.loc 1 106 54 is_stmt 1 view -0
 331              		.cfi_startproc
 332              		@ args = 0, pretend = 0, frame = 0
 333              		@ frame_needed = 0, uses_anonymous_args = 0
 334              		.loc 1 106 54 is_stmt 0 view .LVU90
 335 0000 38B5     		push	{r3, r4, r5, lr}
 336              		.cfi_def_cfa_offset 16
 337              		.cfi_offset 3, -16
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 10


 338              		.cfi_offset 4, -12
 339              		.cfi_offset 5, -8
 340              		.cfi_offset 14, -4
 341              		.loc 1 106 54 view .LVU91
 342 0002 0D46     		mov	r5, r1
 107:source/HvMessagePool.c ****   const hv_size_t b = msg_getSize(m); // the number of bytes that a message occupies in memory
 108:source/HvMessagePool.c ****   const hv_size_t i = mp_messagelistIndexForSize(b); // the HvMessagePoolList index in the pool
 109:source/HvMessagePool.c ****   HvMessagePoolList *ml = &mp->lists[i];
 110:source/HvMessagePool.c ****   const hv_size_t chunkSize = 32 << i;
 343              		.loc 1 110 34 view .LVU92
 344 0004 2022     		movs	r2, #32
 111:source/HvMessagePool.c ****   hv_memclear(m, chunkSize); // clear the chunk, just in case
 345              		.loc 1 111 3 view .LVU93
 346 0006 0021     		movs	r1, #0
 347              	.LVL17:
 107:source/HvMessagePool.c ****   const hv_size_t b = msg_getSize(m); // the number of bytes that a message occupies in memory
 348              		.loc 1 107 3 is_stmt 1 view .LVU94
 349              	.LBB73:
 350              	.LBI73:
 351              		.file 2 "source/HvMessage.h"
   1:source/HvMessage.h **** /**
   2:source/HvMessage.h ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvMessage.h ****  *
   4:source/HvMessage.h ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvMessage.h ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvMessage.h ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvMessage.h ****  *
   8:source/HvMessage.h ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvMessage.h ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvMessage.h ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvMessage.h ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvMessage.h ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvMessage.h ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvMessage.h ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvMessage.h ****  */
  16:source/HvMessage.h **** 
  17:source/HvMessage.h **** #ifndef _HEAVY_MESSAGE_H_
  18:source/HvMessage.h **** #define _HEAVY_MESSAGE_H_
  19:source/HvMessage.h **** 
  20:source/HvMessage.h **** #include "HvUtils.h"
  21:source/HvMessage.h **** 
  22:source/HvMessage.h **** #ifdef __cplusplus
  23:source/HvMessage.h **** extern "C" {
  24:source/HvMessage.h **** #endif
  25:source/HvMessage.h **** 
  26:source/HvMessage.h **** typedef enum ElementType {
  27:source/HvMessage.h ****   HV_MSG_BANG = 0,
  28:source/HvMessage.h ****   HV_MSG_FLOAT = 1,
  29:source/HvMessage.h ****   HV_MSG_SYMBOL = 2,
  30:source/HvMessage.h ****   HV_MSG_HASH = 3
  31:source/HvMessage.h **** } ElementType;
  32:source/HvMessage.h **** 
  33:source/HvMessage.h **** typedef struct Element {
  34:source/HvMessage.h ****   ElementType type;
  35:source/HvMessage.h ****   union {
  36:source/HvMessage.h ****     float f; // float
  37:source/HvMessage.h ****     const char *s; // symbol
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 11


  38:source/HvMessage.h ****     hv_uint32_t h; // hash
  39:source/HvMessage.h ****   } data;
  40:source/HvMessage.h **** } Element;
  41:source/HvMessage.h **** 
  42:source/HvMessage.h **** typedef struct HvMessage {
  43:source/HvMessage.h ****   hv_uint32_t timestamp; // the sample at which this message should be processed
  44:source/HvMessage.h ****   hv_uint16_t numElements;
  45:source/HvMessage.h ****   hv_uint16_t numBytes; // the total number of bytes that this message occupies in memory, includin
  46:source/HvMessage.h ****   Element elem;
  47:source/HvMessage.h **** } HvMessage;
  48:source/HvMessage.h **** 
  49:source/HvMessage.h **** typedef struct ReceiverMessagePair {
  50:source/HvMessage.h ****   hv_uint32_t receiverHash;
  51:source/HvMessage.h ****   HvMessage msg;
  52:source/HvMessage.h **** } ReceiverMessagePair;
  53:source/HvMessage.h **** 
  54:source/HvMessage.h **** #define HV_MESSAGE_ON_STACK(_x) (HvMessage *) hv_alloca(msg_getCoreSize(_x))
  55:source/HvMessage.h **** 
  56:source/HvMessage.h **** /** Returns the number of bytes that this message consumes in memory, not including strings. */
  57:source/HvMessage.h **** static inline hv_size_t msg_getCoreSize(hv_size_t numElements) {
  58:source/HvMessage.h ****   hv_assert(numElements > 0);
  59:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
  60:source/HvMessage.h **** }
  61:source/HvMessage.h **** 
  62:source/HvMessage.h **** HvMessage *msg_copy(const HvMessage *m);
  63:source/HvMessage.h **** 
  64:source/HvMessage.h **** /** Copies the message into the given buffer. The buffer must be at least as large as msg_getNumHea
  65:source/HvMessage.h **** void msg_copyToBuffer(const HvMessage *m, char *buffer, hv_size_t len);
  66:source/HvMessage.h **** 
  67:source/HvMessage.h **** void msg_setElementToFrom(HvMessage *n, int indexN, const HvMessage *const m, int indexM);
  68:source/HvMessage.h **** 
  69:source/HvMessage.h **** /** Frees a message on the heap. Does nothing if argument is NULL. */
  70:source/HvMessage.h **** void msg_free(HvMessage *m);
  71:source/HvMessage.h **** 
  72:source/HvMessage.h **** HvMessage *msg_init(HvMessage *m, hv_size_t numElements, hv_uint32_t timestamp);
  73:source/HvMessage.h **** 
  74:source/HvMessage.h **** HvMessage *msg_initWithFloat(HvMessage *m, hv_uint32_t timestamp, float f);
  75:source/HvMessage.h **** 
  76:source/HvMessage.h **** HvMessage *msg_initWithBang(HvMessage *m, hv_uint32_t timestamp);
  77:source/HvMessage.h **** 
  78:source/HvMessage.h **** HvMessage *msg_initWithSymbol(HvMessage *m, hv_uint32_t timestamp, const char *s);
  79:source/HvMessage.h **** 
  80:source/HvMessage.h **** HvMessage *msg_initWithHash(HvMessage *m, hv_uint32_t timestamp, hv_uint32_t h);
  81:source/HvMessage.h **** 
  82:source/HvMessage.h **** static inline hv_uint32_t msg_getTimestamp(const HvMessage *m) {
  83:source/HvMessage.h ****   return m->timestamp;
  84:source/HvMessage.h **** }
  85:source/HvMessage.h **** 
  86:source/HvMessage.h **** static inline void msg_setTimestamp(HvMessage *m, hv_uint32_t timestamp) {
  87:source/HvMessage.h ****   m->timestamp = timestamp;
  88:source/HvMessage.h **** }
  89:source/HvMessage.h **** 
  90:source/HvMessage.h **** static inline int msg_getNumElements(const HvMessage *m) {
  91:source/HvMessage.h ****   return (int) m->numElements;
  92:source/HvMessage.h **** }
  93:source/HvMessage.h **** 
  94:source/HvMessage.h **** /** Returns the total number of bytes this message consumes in memory. */
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 12


  95:source/HvMessage.h **** static inline hv_uint32_t msg_getSize(const HvMessage *m) {
 352              		.loc 2 95 27 view .LVU95
 353              	.LBB74:
  96:source/HvMessage.h ****   return m->numBytes;
 354              		.loc 2 96 3 view .LVU96
 355              		.loc 2 96 3 is_stmt 0 view .LVU97
 356              	.LBE74:
 357              	.LBE73:
 108:source/HvMessagePool.c ****   HvMessagePoolList *ml = &mp->lists[i];
 358              		.loc 1 108 3 is_stmt 1 view .LVU98
 359              	.LBB76:
 360              	.LBI76:
  80:source/HvMessagePool.c ****   return (hv_size_t) hv_max_i((hv_min_max_log2((hv_uint32_t) byteSize) - 5), 0);
 361              		.loc 1 80 18 view .LVU99
 362              	.LBB77:
  81:source/HvMessagePool.c **** }
 363              		.loc 1 81 3 view .LVU100
 364              	.LBB78:
 365              	.LBI78:
 366              		.file 3 "source/HvUtils.h"
   1:source/HvUtils.h **** /**
   2:source/HvUtils.h ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvUtils.h ****  *
   4:source/HvUtils.h ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvUtils.h ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvUtils.h ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvUtils.h ****  *
   8:source/HvUtils.h ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvUtils.h ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvUtils.h ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvUtils.h ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvUtils.h ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvUtils.h ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvUtils.h ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvUtils.h ****  */
  16:source/HvUtils.h **** 
  17:source/HvUtils.h **** #ifndef _HEAVY_UTILS_H_
  18:source/HvUtils.h **** #define _HEAVY_UTILS_H_
  19:source/HvUtils.h **** 
  20:source/HvUtils.h **** // platform definitions
  21:source/HvUtils.h **** #if _WIN32 || _WIN64
  22:source/HvUtils.h ****   #define HV_WIN 1
  23:source/HvUtils.h **** #ifdef _MSC_VER
  24:source/HvUtils.h ****   #define HV_MSVC 1
  25:source/HvUtils.h **** #endif
  26:source/HvUtils.h **** #elif __APPLE__
  27:source/HvUtils.h ****   #define HV_APPLE 1
  28:source/HvUtils.h **** #elif __ANDROID__
  29:source/HvUtils.h ****   #define HV_ANDROID 1
  30:source/HvUtils.h **** #elif __unix__ || __unix
  31:source/HvUtils.h ****   #define HV_UNIX 1
  32:source/HvUtils.h **** #else
  33:source/HvUtils.h ****   #warning Could not detect platform. Assuming Unix-like.
  34:source/HvUtils.h **** #endif
  35:source/HvUtils.h **** 
  36:source/HvUtils.h **** #ifdef EMSCRIPTEN
  37:source/HvUtils.h **** #define HV_EMSCRIPTEN 1
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 13


  38:source/HvUtils.h **** #endif
  39:source/HvUtils.h **** 
  40:source/HvUtils.h **** // basic includes
  41:source/HvUtils.h **** #include <stdarg.h>
  42:source/HvUtils.h **** #include <stdio.h>
  43:source/HvUtils.h **** #include <stdlib.h>
  44:source/HvUtils.h **** 
  45:source/HvUtils.h **** // type definitions
  46:source/HvUtils.h **** #include <stdint.h>
  47:source/HvUtils.h **** #include <stdbool.h>
  48:source/HvUtils.h **** #define hv_uint8_t uint8_t
  49:source/HvUtils.h **** #define hv_int16_t int16_t
  50:source/HvUtils.h **** #define hv_uint16_t uint16_t
  51:source/HvUtils.h **** #define hv_int32_t int32_t
  52:source/HvUtils.h **** #define hv_uint32_t uint32_t
  53:source/HvUtils.h **** #define hv_uint64_t uint64_t
  54:source/HvUtils.h **** #define hv_size_t size_t
  55:source/HvUtils.h **** #define hv_uintptr_t uintptr_t
  56:source/HvUtils.h **** 
  57:source/HvUtils.h **** // SIMD-specific includes
  58:source/HvUtils.h **** #if !(HV_SIMD_NONE || HV_SIMD_NEON || HV_SIMD_SSE || HV_SIMD_AVX)
  59:source/HvUtils.h ****   #define HV_SIMD_NEON __ARM_NEON__
  60:source/HvUtils.h ****   #define HV_SIMD_SSE (__SSE__ && __SSE2__ && __SSE3__ && __SSSE3__ && __SSE4_1__)
  61:source/HvUtils.h ****   #define HV_SIMD_AVX (__AVX__ && HV_SIMD_SSE)
  62:source/HvUtils.h **** #endif
  63:source/HvUtils.h **** #ifndef HV_SIMD_FMA
  64:source/HvUtils.h ****   #define HV_SIMD_FMA __FMA__
  65:source/HvUtils.h **** #endif
  66:source/HvUtils.h **** 
  67:source/HvUtils.h **** #if HV_SIMD_AVX || HV_SIMD_SSE
  68:source/HvUtils.h ****   #include <immintrin.h>
  69:source/HvUtils.h **** #elif HV_SIMD_NEON
  70:source/HvUtils.h ****   #include <arm_neon.h>
  71:source/HvUtils.h **** #endif
  72:source/HvUtils.h **** 
  73:source/HvUtils.h **** #if HV_SIMD_NEON // NEON
  74:source/HvUtils.h ****   #define HV_N_SIMD 4
  75:source/HvUtils.h ****   #define hv_bufferf_t float32x4_t
  76:source/HvUtils.h ****   #define hv_bufferi_t int32x4_t
  77:source/HvUtils.h ****   #define hv_bInf_t float32x4_t
  78:source/HvUtils.h ****   #define hv_bOutf_t float32x4_t*
  79:source/HvUtils.h ****   #define hv_bIni_t int32x4_t
  80:source/HvUtils.h ****   #define hv_bOuti_t int32x4_t*
  81:source/HvUtils.h ****   #define VIf(_x) (_x)
  82:source/HvUtils.h ****   #define VOf(_x) (&_x)
  83:source/HvUtils.h ****   #define VIi(_x) (_x)
  84:source/HvUtils.h ****   #define VOi(_x) (&_x)
  85:source/HvUtils.h **** #elif HV_SIMD_AVX // AVX
  86:source/HvUtils.h ****   #define HV_N_SIMD 8
  87:source/HvUtils.h ****   #define hv_bufferf_t __m256
  88:source/HvUtils.h ****   #define hv_bufferi_t __m256i
  89:source/HvUtils.h ****   #define hv_bInf_t __m256
  90:source/HvUtils.h ****   #define hv_bOutf_t __m256*
  91:source/HvUtils.h ****   #define hv_bIni_t __m256i
  92:source/HvUtils.h ****   #define hv_bOuti_t __m256i*
  93:source/HvUtils.h ****   #define VIf(_x) (_x)
  94:source/HvUtils.h ****   #define VOf(_x) (&_x)
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 14


  95:source/HvUtils.h ****   #define VIi(_x) (_x)
  96:source/HvUtils.h ****   #define VOi(_x) (&_x)
  97:source/HvUtils.h **** #elif HV_SIMD_SSE // SSE
  98:source/HvUtils.h ****   #define HV_N_SIMD 4
  99:source/HvUtils.h ****   #define hv_bufferf_t __m128
 100:source/HvUtils.h ****   #define hv_bufferi_t __m128i
 101:source/HvUtils.h ****   #define hv_bInf_t __m128
 102:source/HvUtils.h ****   #define hv_bOutf_t __m128*
 103:source/HvUtils.h ****   #define hv_bIni_t __m128i
 104:source/HvUtils.h ****   #define hv_bOuti_t __m128i*
 105:source/HvUtils.h ****   #define VIf(_x) (_x)
 106:source/HvUtils.h ****   #define VOf(_x) (&_x)
 107:source/HvUtils.h ****   #define VIi(_x) (_x)
 108:source/HvUtils.h ****   #define VOi(_x) (&_x)
 109:source/HvUtils.h **** #else // DEFAULT
 110:source/HvUtils.h ****   #define HV_N_SIMD 1
 111:source/HvUtils.h ****   #undef HV_SIMD_NONE
 112:source/HvUtils.h ****   #define HV_SIMD_NONE 1
 113:source/HvUtils.h ****   #define hv_bufferf_t float
 114:source/HvUtils.h ****   #define hv_bufferi_t int
 115:source/HvUtils.h ****   #define hv_bInf_t float
 116:source/HvUtils.h ****   #define hv_bOutf_t float*
 117:source/HvUtils.h ****   #define hv_bIni_t int
 118:source/HvUtils.h ****   #define hv_bOuti_t int*
 119:source/HvUtils.h ****   #define VIf(_x) (_x)
 120:source/HvUtils.h ****   #define VOf(_x) (&_x)
 121:source/HvUtils.h ****   #define VIi(_x) (_x)
 122:source/HvUtils.h ****   #define VOi(_x) (&_x)
 123:source/HvUtils.h **** #endif
 124:source/HvUtils.h **** 
 125:source/HvUtils.h **** #define HV_N_SIMD_MASK (HV_N_SIMD-1)
 126:source/HvUtils.h **** 
 127:source/HvUtils.h **** // Strings
 128:source/HvUtils.h **** #include <string.h>
 129:source/HvUtils.h **** #define hv_strlen(a) strlen(a)
 130:source/HvUtils.h **** #define hv_strcmp(a, b) strcmp(a, b)
 131:source/HvUtils.h **** #define hv_snprintf(a, b, c, ...) snprintf(a, b, c, __VA_ARGS__)
 132:source/HvUtils.h **** #if HV_WIN
 133:source/HvUtils.h **** #define hv_strncpy(_dst, _src, _len) strncpy_s(_dst, _len, _src, _TRUNCATE)
 134:source/HvUtils.h **** #else
 135:source/HvUtils.h **** #define hv_strncpy(_dst, _src, _len) strncpy(_dst, _src, _len)
 136:source/HvUtils.h **** #endif
 137:source/HvUtils.h **** 
 138:source/HvUtils.h **** // Memory management
 139:source/HvUtils.h **** #define hv_memcpy(a, b, c) memcpy(a, b, c)
 140:source/HvUtils.h **** #define hv_memclear(a, b) memset(a, 0, b)
 141:source/HvUtils.h **** #if HV_MSVC
 142:source/HvUtils.h ****   #include <malloc.h>
 143:source/HvUtils.h ****   #define hv_alloca(_n) _alloca(_n)
 144:source/HvUtils.h ****   #if HV_SIMD_AVX
 145:source/HvUtils.h ****     #define hv_malloc(_n) _aligned_malloc(_n, 32)
 146:source/HvUtils.h ****     #define hv_realloc(a, b) _aligned_realloc(a, b, 32)
 147:source/HvUtils.h ****     #define hv_free(x) _aligned_free(x)
 148:source/HvUtils.h ****   #elif HV_SIMD_SSE || HV_SIMD_NEON
 149:source/HvUtils.h ****     #define hv_malloc(_n) _aligned_malloc(_n, 16)
 150:source/HvUtils.h ****     #define hv_realloc(a, b) _aligned_realloc(a, b, 16)
 151:source/HvUtils.h ****     #define hv_free(x) _aligned_free(x)
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 15


 152:source/HvUtils.h ****   #else // HV_SIMD_NONE
 153:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 154:source/HvUtils.h ****     #define hv_realloc(a, b) realloc(a, b)
 155:source/HvUtils.h ****     #define hv_free(_n) free(_n)
 156:source/HvUtils.h ****   #endif
 157:source/HvUtils.h **** #elif HV_APPLE
 158:source/HvUtils.h ****   #define hv_alloca(_n) alloca(_n)
 159:source/HvUtils.h ****   #define hv_realloc(a, b) realloc(a, b)
 160:source/HvUtils.h ****   #if HV_SIMD_AVX
 161:source/HvUtils.h ****     #include <mm_malloc.h>
 162:source/HvUtils.h ****     #define hv_malloc(_n) _mm_malloc(_n, 32)
 163:source/HvUtils.h ****     #define hv_free(x) _mm_free(x)
 164:source/HvUtils.h ****   #elif HV_SIMD_SSE
 165:source/HvUtils.h ****     #include <mm_malloc.h>
 166:source/HvUtils.h ****     #define hv_malloc(_n) _mm_malloc(_n, 16)
 167:source/HvUtils.h ****     #define hv_free(x) _mm_free(x)
 168:source/HvUtils.h ****   #elif HV_SIMD_NEON
 169:source/HvUtils.h ****     // malloc on ios always has 16-byte alignment
 170:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 171:source/HvUtils.h ****     #define hv_free(x) free(x)
 172:source/HvUtils.h ****   #else // HV_SIMD_NONE
 173:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 174:source/HvUtils.h ****     #define hv_free(x) free(x)
 175:source/HvUtils.h ****   #endif
 176:source/HvUtils.h **** #else
 177:source/HvUtils.h ****   #include <alloca.h>
 178:source/HvUtils.h ****   #define hv_alloca(_n) alloca(_n)
 179:source/HvUtils.h ****   #define hv_realloc(a, b) realloc(a, b)
 180:source/HvUtils.h ****   #if HV_SIMD_AVX
 181:source/HvUtils.h ****     #define hv_malloc(_n) aligned_alloc(32, _n)
 182:source/HvUtils.h ****     #define hv_free(x) free(x)
 183:source/HvUtils.h ****   #elif HV_SIMD_SSE
 184:source/HvUtils.h ****     #define hv_malloc(_n) aligned_alloc(16, _n)
 185:source/HvUtils.h ****     #define hv_free(x) free(x)
 186:source/HvUtils.h ****   #elif HV_SIMD_NEON
 187:source/HvUtils.h ****     #if HV_ANDROID
 188:source/HvUtils.h ****       #define hv_malloc(_n) memalign(16, _n)
 189:source/HvUtils.h ****       #define hv_free(x) free(x)
 190:source/HvUtils.h ****     #else
 191:source/HvUtils.h ****       #define hv_malloc(_n) aligned_alloc(16, _n)
 192:source/HvUtils.h ****       #define hv_free(x) free(x)
 193:source/HvUtils.h ****     #endif
 194:source/HvUtils.h ****   #else // HV_SIMD_NONE
 195:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 196:source/HvUtils.h ****     #define hv_free(_n) free(_n)
 197:source/HvUtils.h ****   #endif
 198:source/HvUtils.h **** #endif
 199:source/HvUtils.h **** 
 200:source/HvUtils.h **** // Assert
 201:source/HvUtils.h **** #include <assert.h>
 202:source/HvUtils.h **** #define hv_assert(e) assert(e)
 203:source/HvUtils.h **** 
 204:source/HvUtils.h **** // Export and Inline
 205:source/HvUtils.h **** #if HV_MSVC
 206:source/HvUtils.h **** #define HV_EXPORT __declspec(dllexport)
 207:source/HvUtils.h **** #define inline __inline
 208:source/HvUtils.h **** #define HV_FORCE_INLINE __forceinline
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 16


 209:source/HvUtils.h **** #else
 210:source/HvUtils.h **** #define HV_EXPORT
 211:source/HvUtils.h **** #define HV_FORCE_INLINE inline __attribute__((always_inline))
 212:source/HvUtils.h **** #endif
 213:source/HvUtils.h **** 
 214:source/HvUtils.h **** #ifdef __cplusplus
 215:source/HvUtils.h **** extern "C" {
 216:source/HvUtils.h **** #endif
 217:source/HvUtils.h ****   // Returns a 32-bit hash of any string. Returns 0 if string is NULL.
 218:source/HvUtils.h ****   hv_uint32_t hv_string_to_hash(const char *str);
 219:source/HvUtils.h **** #ifdef __cplusplus
 220:source/HvUtils.h **** }
 221:source/HvUtils.h **** #endif
 222:source/HvUtils.h **** 
 223:source/HvUtils.h **** // Math
 224:source/HvUtils.h **** #include <math.h>
 225:source/HvUtils.h **** static inline hv_size_t __hv_utils_max_ui(hv_size_t x, hv_size_t y) { return (x > y) ? x : y; }
 226:source/HvUtils.h **** static inline hv_size_t __hv_utils_min_ui(hv_size_t x, hv_size_t y) { return (x < y) ? x : y; }
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_max_i(hv_int32_t x, hv_int32_t y) { return (x > y) ? x : y; }
 228:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 229:source/HvUtils.h **** #define hv_max_ui(a, b) __hv_utils_max_ui(a, b)
 230:source/HvUtils.h **** #define hv_min_ui(a, b) __hv_utils_min_ui(a, b)
 231:source/HvUtils.h **** #define hv_max_i(a, b) __hv_utils_max_i(a, b)
 232:source/HvUtils.h **** #define hv_min_i(a, b) __hv_utils_min_i(a, b)
 233:source/HvUtils.h **** #define hv_max_f(a, b) fmaxf(a, b)
 234:source/HvUtils.h **** #define hv_min_f(a, b) fminf(a, b)
 235:source/HvUtils.h **** #define hv_max_d(a, b) fmax(a, b)
 236:source/HvUtils.h **** #define hv_min_d(a, b) fmin(a, b)
 237:source/HvUtils.h **** #define hv_sin_f(a) sinf(a)
 238:source/HvUtils.h **** #define hv_sinh_f(a) sinhf(a)
 239:source/HvUtils.h **** #define hv_cos_f(a) cosf(a)
 240:source/HvUtils.h **** #define hv_cosh_f(a) coshf(a)
 241:source/HvUtils.h **** #define hv_tan_f(a) tanf(a)
 242:source/HvUtils.h **** #define hv_tanh_f(a) tanhf(a)
 243:source/HvUtils.h **** #define hv_asin_f(a) asinf(a)
 244:source/HvUtils.h **** #define hv_asinh_f(a) asinhf(a)
 245:source/HvUtils.h **** #define hv_acos_f(a) acosf(a)
 246:source/HvUtils.h **** #define hv_acosh_f(a) acoshf(a)
 247:source/HvUtils.h **** #define hv_atan_f(a) atanf(a)
 248:source/HvUtils.h **** #define hv_atanh_f(a) atanhf(a)
 249:source/HvUtils.h **** #define hv_atan2_f(a, b) atan2f(a, b)
 250:source/HvUtils.h **** #define hv_exp_f(a) expf(a)
 251:source/HvUtils.h **** #define hv_abs_f(a) fabsf(a)
 252:source/HvUtils.h **** #define hv_sqrt_f(a) sqrtf(a)
 253:source/HvUtils.h **** #define hv_log_f(a) logf(a)
 254:source/HvUtils.h **** #define hv_ceil_f(a) ceilf(a)
 255:source/HvUtils.h **** #define hv_floor_f(a) floorf(a)
 256:source/HvUtils.h **** #define hv_round_f(a) roundf(a)
 257:source/HvUtils.h **** #define hv_pow_f(a, b) powf(a, b)
 258:source/HvUtils.h **** #if HV_EMSCRIPTEN
 259:source/HvUtils.h **** #define hv_fma_f(a, b, c) ((a*b)+c) // emscripten does not support fmaf (yet?)
 260:source/HvUtils.h **** #else
 261:source/HvUtils.h **** #define hv_fma_f(a, b, c) fmaf(a, b, c)
 262:source/HvUtils.h **** #endif
 263:source/HvUtils.h **** #if HV_MSVC
 264:source/HvUtils.h ****   // finds ceil(log2(x))
 265:source/HvUtils.h ****   #include <intrin.h>
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 17


 266:source/HvUtils.h ****   static inline hv_uint32_t __hv_utils_min_max_log2(hv_uint32_t x) {
 267:source/HvUtils.h ****     unsigned long z = 0;
 268:source/HvUtils.h ****     _BitScanReverse(&z, x);
 269:source/HvUtils.h ****     return (hv_uint32_t) (z+1);
 270:source/HvUtils.h ****   }
 271:source/HvUtils.h **** #else
 272:source/HvUtils.h ****   static inline hv_uint32_t __hv_utils_min_max_log2(hv_uint32_t x) {
 367              		.loc 3 272 29 view .LVU101
 368              	.LBB79:
 273:source/HvUtils.h ****     return (hv_uint32_t) (32 - __builtin_clz(x-1));
 369              		.loc 3 273 5 view .LVU102
 370              	.LBE79:
 371              	.LBE78:
 372              	.LBE77:
 373              	.LBE76:
 374              	.LBB87:
 375              	.LBB75:
 376              		.loc 2 96 11 is_stmt 0 view .LVU103
 377 0008 EB88     		ldrh	r3, [r5, #6]
 378              	.LBE75:
 379              	.LBE87:
 380              	.LBB88:
 381              	.LBB86:
 382              	.LBB81:
 383              	.LBB80:
 384              		.loc 3 273 47 view .LVU104
 385 000a 013B     		subs	r3, r3, #1
 386              		.loc 3 273 32 view .LVU105
 387 000c B3FA83F3 		clz	r3, r3
 388              	.LVL18:
 389              		.loc 3 273 32 view .LVU106
 390              	.LBE80:
 391              	.LBE81:
 392              	.LBB82:
 393              	.LBI82:
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 394              		.loc 3 227 26 is_stmt 1 view .LVU107
 395              	.LBB83:
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 396              		.loc 3 227 73 view .LVU108
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 397              		.loc 3 227 73 is_stmt 0 view .LVU109
 398              	.LBE83:
 399              	.LBE82:
  81:source/HvMessagePool.c **** }
 400              		.loc 1 81 22 view .LVU110
 401 0010 C3F11B03 		rsb	r3, r3, #27
 402              	.LBB85:
 403              	.LBB84:
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 404              		.loc 3 227 92 view .LVU111
 405 0014 23EAE373 		bic	r3, r3, r3, asr #31
 406              	.LVL19:
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 407              		.loc 3 227 92 view .LVU112
 408              	.LBE84:
 409              	.LBE85:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 18


 410              	.LBE86:
 411              	.LBE88:
 109:source/HvMessagePool.c ****   const hv_size_t chunkSize = 32 << i;
 412              		.loc 1 109 3 is_stmt 1 view .LVU113
 110:source/HvMessagePool.c ****   hv_memclear(m, chunkSize); // clear the chunk, just in case
 413              		.loc 1 110 3 view .LVU114
 414              		.loc 1 111 3 view .LVU115
 415 0018 00EBC304 		add	r4, r0, r3, lsl #3
 416 001c 9A40     		lsls	r2, r2, r3
 417              	.LVL20:
 418              		.loc 1 111 3 is_stmt 0 view .LVU116
 419 001e 2846     		mov	r0, r5
 420              	.LVL21:
 421              		.loc 1 111 3 view .LVU117
 422 0020 FFF7FEFF 		bl	memset
 423              	.LVL22:
 112:source/HvMessagePool.c ****   ml_push(ml, m);
 424              		.loc 1 112 3 is_stmt 1 view .LVU118
 425              	.LBB89:
 426              	.LBI89:
  47:source/HvMessagePool.c ****   MessageListNode *n = NULL;
 427              		.loc 1 47 13 view .LVU119
 428              	.LBB90:
  48:source/HvMessagePool.c ****   if (ml->pool != NULL) {
 429              		.loc 1 48 3 view .LVU120
  49:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
 430              		.loc 1 49 3 view .LVU121
  49:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
 431              		.loc 1 49 9 is_stmt 0 view .LVU122
 432 0024 2069     		ldr	r0, [r4, #16]
  49:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
 433              		.loc 1 49 6 view .LVU123
 434 0026 30B1     		cbz	r0, .L35
  51:source/HvMessagePool.c ****     ml->pool = n->next;
 435              		.loc 1 51 5 is_stmt 1 view .LVU124
 436              	.LVL23:
  52:source/HvMessagePool.c ****   } else {
 437              		.loc 1 52 5 view .LVU125
  52:source/HvMessagePool.c ****   } else {
 438              		.loc 1 52 14 is_stmt 0 view .LVU126
 439 0028 4268     		ldr	r2, [r0, #4]
 440 002a 2261     		str	r2, [r4, #16]
 441              	.L36:
  58:source/HvMessagePool.c ****   n->next = ml->head;
 442              		.loc 1 58 3 is_stmt 1 view .LVU127
  59:source/HvMessagePool.c ****   ml->head = n; // push to the front of the queue
 443              		.loc 1 59 11 is_stmt 0 view .LVU128
 444 002c E268     		ldr	r2, [r4, #12]
 445 002e C0E90052 		strd	r5, r2, [r0]
  60:source/HvMessagePool.c **** }
 446              		.loc 1 60 3 is_stmt 1 view .LVU129
  60:source/HvMessagePool.c **** }
 447              		.loc 1 60 12 is_stmt 0 view .LVU130
 448 0032 E060     		str	r0, [r4, #12]
 449              	.LVL24:
  60:source/HvMessagePool.c **** }
 450              		.loc 1 60 12 view .LVU131
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 19


 451              	.LBE90:
 452              	.LBE89:
 113:source/HvMessagePool.c **** }
 453              		.loc 1 113 1 view .LVU132
 454 0034 38BD     		pop	{r3, r4, r5, pc}
 455              	.LVL25:
 456              	.L35:
 457              	.LBB92:
 458              	.LBB91:
  55:source/HvMessagePool.c ****     hv_assert(n != NULL);
 459              		.loc 1 55 5 is_stmt 1 view .LVU133
  55:source/HvMessagePool.c ****     hv_assert(n != NULL);
 460              		.loc 1 55 29 is_stmt 0 view .LVU134
 461 0036 0820     		movs	r0, #8
 462 0038 FFF7FEFF 		bl	malloc
 463              	.LVL26:
  56:source/HvMessagePool.c ****   }
 464              		.loc 1 56 5 is_stmt 1 view .LVU135
 465 003c 0028     		cmp	r0, #0
 466 003e F5D1     		bne	.L36
 467 0040 FFF7FEFF 		bl	ml_push.part.0
 468              	.LVL27:
  56:source/HvMessagePool.c ****   }
 469              		.loc 1 56 5 is_stmt 0 view .LVU136
 470              	.LBE91:
 471              	.LBE92:
 472              		.cfi_endproc
 473              	.LFE352:
 475              		.section	.rodata.mp_addMessage.str1.4,"aMS",%progbits,1
 476              		.align	2
 477              	.LC3:
 478 0000 69203C20 		.ascii	"i < 4\000"
 478      3400
 479 0006 0000     		.align	2
 480              	.LC4:
 481 0008 286E6577 		.ascii	"(newIndex <= mp->bufferSize) && \"The message pool "
 481      496E6465 
 481      78203C3D 
 481      206D702D 
 481      3E627566 
 482 003a 62756666 		.ascii	"buffer size has been exceeded. The context cannot s"
 482      65722073 
 482      697A6520 
 482      68617320 
 482      6265656E 
 483 006d 746F7265 		.ascii	"tore more messages. \" \"Try using the new_with_opt"
 483      206D6F72 
 483      65206D65 
 483      73736167 
 483      65732E20 
 484 009e 696F6E73 		.ascii	"ions() initialiser with a larger pool size (default"
 484      28292069 
 484      6E697469 
 484      616C6973 
 484      65722077 
 485 00d1 20697320 		.ascii	" is 10KB).\"\000"
 485      31304B42 
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 20


 485      292E2200 
 486              		.section	.text.mp_addMessage,"ax",%progbits
 487              		.align	1
 488              		.p2align 2,,3
 489              		.global	mp_addMessage
 490              		.syntax unified
 491              		.thumb
 492              		.thumb_func
 494              	mp_addMessage:
 495              	.LVL28:
 496              	.LFB353:
 114:source/HvMessagePool.c **** 
 115:source/HvMessagePool.c **** HvMessage *mp_addMessage(HvMessagePool *mp, const HvMessage *m) {
 497              		.loc 1 115 65 is_stmt 1 view -0
 498              		.cfi_startproc
 499              		@ args = 0, pretend = 0, frame = 8
 500              		@ frame_needed = 0, uses_anonymous_args = 0
 116:source/HvMessagePool.c ****   const hv_size_t b = msg_getSize(m);
 501              		.loc 1 116 3 view .LVU138
 502              	.LBB112:
 503              	.LBI112:
  95:source/HvMessage.h ****   return m->numBytes;
 504              		.loc 2 95 27 view .LVU139
 505              	.LBB113:
 506              		.loc 2 96 3 view .LVU140
 507              		.loc 2 96 3 is_stmt 0 view .LVU141
 508              	.LBE113:
 509              	.LBE112:
 117:source/HvMessagePool.c ****   // determine the message list index to allocate data from based on the msg size
 118:source/HvMessagePool.c ****   // smallest chunk size is 32 bytes
 119:source/HvMessagePool.c ****   const hv_size_t i = mp_messagelistIndexForSize(b);
 510              		.loc 1 119 3 is_stmt 1 view .LVU142
 511              	.LBB115:
 512              	.LBI115:
  80:source/HvMessagePool.c ****   return (hv_size_t) hv_max_i((hv_min_max_log2((hv_uint32_t) byteSize) - 5), 0);
 513              		.loc 1 80 18 view .LVU143
 514              	.LBB116:
  81:source/HvMessagePool.c **** }
 515              		.loc 1 81 3 view .LVU144
 516              	.LBB117:
 517              	.LBI117:
 272:source/HvUtils.h ****     return (hv_uint32_t) (32 - __builtin_clz(x-1));
 518              		.loc 3 272 29 view .LVU145
 519              	.LBB118:
 520              		.loc 3 273 5 view .LVU146
 521              	.LBE118:
 522              	.LBE117:
 523              	.LBE116:
 524              	.LBE115:
 525              	.LBB124:
 526              	.LBB114:
 527              		.loc 2 96 11 is_stmt 0 view .LVU147
 528 0000 CB88     		ldrh	r3, [r1, #6]
 529              	.LBE114:
 530              	.LBE124:
 531              	.LBB125:
 532              	.LBB123:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 21


 533              	.LBB120:
 534              	.LBB119:
 535              		.loc 3 273 47 view .LVU148
 536 0002 013B     		subs	r3, r3, #1
 537              		.loc 3 273 32 view .LVU149
 538 0004 B3FA83F3 		clz	r3, r3
 539              	.LVL29:
 540              		.loc 3 273 32 view .LVU150
 541              	.LBE119:
 542              	.LBE120:
  81:source/HvMessagePool.c **** }
 543              		.loc 1 81 22 view .LVU151
 544 0008 C3F11B03 		rsb	r3, r3, #27
 545              	.LVL30:
 546              	.LBB121:
 547              	.LBI121:
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 548              		.loc 3 227 26 is_stmt 1 view .LVU152
 549              	.LBB122:
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 550              		.loc 3 227 73 view .LVU153
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 551              		.loc 3 227 73 is_stmt 0 view .LVU154
 552              	.LBE122:
 553              	.LBE121:
 554              	.LBE123:
 555              	.LBE125:
 120:source/HvMessagePool.c **** 
 121:source/HvMessagePool.c ****   hv_assert(i < MP_NUM_MESSAGE_LISTS); // how many chunk sizes do we want to support? 32, 64, 128, 
 556              		.loc 1 121 3 is_stmt 1 view .LVU155
 557 000c 032B     		cmp	r3, #3
 115:source/HvMessagePool.c ****   const hv_size_t b = msg_getSize(m);
 558              		.loc 1 115 65 is_stmt 0 view .LVU156
 559 000e 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 560              		.cfi_def_cfa_offset 36
 561              		.cfi_offset 4, -36
 562              		.cfi_offset 5, -32
 563              		.cfi_offset 6, -28
 564              		.cfi_offset 7, -24
 565              		.cfi_offset 8, -20
 566              		.cfi_offset 9, -16
 567              		.cfi_offset 10, -12
 568              		.cfi_offset 11, -8
 569              		.cfi_offset 14, -4
 570 0012 83B0     		sub	sp, sp, #12
 571              		.cfi_def_cfa_offset 48
 572              		.loc 1 121 3 view .LVU157
 573 0014 4BDC     		bgt	.L55
 122:source/HvMessagePool.c ****   HvMessagePoolList *ml = &mp->lists[i];
 574              		.loc 1 122 3 is_stmt 1 view .LVU158
 575              	.LVL31:
 123:source/HvMessagePool.c ****   const hv_size_t chunkSize = 32 << i;
 576              		.loc 1 123 3 view .LVU159
 577 0016 23EAE372 		bic	r2, r3, r3, asr #31
 578              	.LVL32:
 579              		.loc 1 123 34 is_stmt 0 view .LVU160
 580 001a 4FF02008 		mov	r8, #32
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 22


 581 001e 8946     		mov	r9, r1
 582 0020 8246     		mov	r10, r0
 583 0022 00EBC205 		add	r5, r0, r2, lsl #3
 584 0026 08FA02F8 		lsl	r8, r8, r2
 585              	.LVL33:
 124:source/HvMessagePool.c **** 
 125:source/HvMessagePool.c ****   if (ml_hasAvailable(ml)) {
 586              		.loc 1 125 3 is_stmt 1 view .LVU161
 587              	.LBB126:
 588              	.LBI126:
  32:source/HvMessagePool.c ****   return (ml->head != NULL);
 589              		.loc 1 32 20 view .LVU162
 590              	.LBB127:
  33:source/HvMessagePool.c **** }
 591              		.loc 1 33 3 view .LVU163
  33:source/HvMessagePool.c **** }
 592              		.loc 1 33 13 is_stmt 0 view .LVU164
 593 002a EB68     		ldr	r3, [r5, #12]
 594 002c 1E46     		mov	r6, r3
 595              	.LVL34:
  33:source/HvMessagePool.c **** }
 596              		.loc 1 33 13 view .LVU165
 597              	.LBE127:
 598              	.LBE126:
 599              		.loc 1 125 6 view .LVU166
 600 002e 002B     		cmp	r3, #0
 601 0030 33D1     		bne	.L56
 602              	.LBB128:
 126:source/HvMessagePool.c ****     char *buf = ml_pop(ml);
 127:source/HvMessagePool.c ****     msg_copyToBuffer(m, buf, chunkSize);
 128:source/HvMessagePool.c ****     return (HvMessage *) buf;
 129:source/HvMessagePool.c ****   } else {
 130:source/HvMessagePool.c ****     // if no appropriately sized buffer is immediately available, increase the size of the used buf
 131:source/HvMessagePool.c ****     const hv_size_t newIndex = mp->bufferIndex + MP_BLOCK_SIZE_BYTES;
 603              		.loc 1 131 5 is_stmt 1 view .LVU167
 132:source/HvMessagePool.c ****     hv_assert((newIndex <= mp->bufferSize) &&
 604              		.loc 1 132 5 is_stmt 0 view .LVU168
 605 0032 D0E90124 		ldrd	r2, r4, [r0, #4]
 606              	.LVL35:
 131:source/HvMessagePool.c ****     hv_assert((newIndex <= mp->bufferSize) &&
 607              		.loc 1 131 21 view .LVU169
 608 0036 04F5007B 		add	fp, r4, #512
 609              	.LVL36:
 610              		.loc 1 132 5 is_stmt 1 view .LVU170
 611 003a 5A45     		cmp	r2, fp
 612 003c 3DD3     		bcc	.L42
 613              	.LVL37:
 614              	.LBB129:
 133:source/HvMessagePool.c ****         "The message pool buffer size has been exceeded. The context cannot store more messages. "
 134:source/HvMessagePool.c ****         "Try using the new_with_options() initialiser with a larger pool size (default is 10KB).");
 135:source/HvMessagePool.c **** 
 136:source/HvMessagePool.c ****     for (hv_size_t j = mp->bufferIndex; j < newIndex; j += chunkSize) {
 615              		.loc 1 136 41 view .LVU171
 616              		.loc 1 136 5 is_stmt 0 view .LVU172
 617 003e 5C45     		cmp	r4, fp
 618 0040 18D2     		bcs	.L57
 137:source/HvMessagePool.c ****       ml_push(ml, mp->buffer + j); // push new nodes onto the list with chunk pointers
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 23


 619              		.loc 1 137 21 view .LVU173
 620 0042 0168     		ldr	r1, [r0]
 621              	.LVL38:
 622              		.loc 1 137 21 view .LVU174
 623 0044 09E0     		b	.L47
 624              	.LVL39:
 625              	.L58:
 626              	.LBB130:
 627              	.LBB131:
  51:source/HvMessagePool.c ****     ml->pool = n->next;
 628              		.loc 1 51 5 is_stmt 1 view .LVU175
  52:source/HvMessagePool.c ****   } else {
 629              		.loc 1 52 5 view .LVU176
  52:source/HvMessagePool.c ****   } else {
 630              		.loc 1 52 14 is_stmt 0 view .LVU177
 631 0046 5A68     		ldr	r2, [r3, #4]
 632 0048 2A61     		str	r2, [r5, #16]
 633              	.L46:
  58:source/HvMessagePool.c ****   n->next = ml->head;
 634              		.loc 1 58 3 is_stmt 1 view .LVU178
 635              	.LBE131:
 636              	.LBE130:
 136:source/HvMessagePool.c ****       ml_push(ml, mp->buffer + j); // push new nodes onto the list with chunk pointers
 637              		.loc 1 136 57 is_stmt 0 view .LVU179
 638 004a 4444     		add	r4, r4, r8
 639              	.LVL40:
 640              	.LBB137:
 641              	.LBB132:
  59:source/HvMessagePool.c ****   ml->head = n; // push to the front of the queue
 642              		.loc 1 59 15 view .LVU180
 643 004c 3246     		mov	r2, r6
 644              	.LBE132:
 645              	.LBE137:
 136:source/HvMessagePool.c ****       ml_push(ml, mp->buffer + j); // push new nodes onto the list with chunk pointers
 646              		.loc 1 136 5 view .LVU181
 647 004e A345     		cmp	fp, r4
 648              	.LBB138:
 649              	.LBB133:
  58:source/HvMessagePool.c ****   n->next = ml->head;
 650              		.loc 1 58 8 view .LVU182
 651 0050 C3E90076 		strd	r7, r6, [r3]
  59:source/HvMessagePool.c ****   ml->head = n; // push to the front of the queue
 652              		.loc 1 59 3 is_stmt 1 view .LVU183
  60:source/HvMessagePool.c **** }
 653              		.loc 1 60 3 view .LVU184
  60:source/HvMessagePool.c **** }
 654              		.loc 1 60 12 is_stmt 0 view .LVU185
 655 0054 1E46     		mov	r6, r3
 656 0056 EB60     		str	r3, [r5, #12]
 657              	.LVL41:
  60:source/HvMessagePool.c **** }
 658              		.loc 1 60 12 view .LVU186
 659              	.LBE133:
 660              	.LBE138:
 136:source/HvMessagePool.c ****       ml_push(ml, mp->buffer + j); // push new nodes onto the list with chunk pointers
 661              		.loc 1 136 55 is_stmt 1 view .LVU187
 136:source/HvMessagePool.c ****       ml_push(ml, mp->buffer + j); // push new nodes onto the list with chunk pointers
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 24


 662              		.loc 1 136 41 view .LVU188
 136:source/HvMessagePool.c ****       ml_push(ml, mp->buffer + j); // push new nodes onto the list with chunk pointers
 663              		.loc 1 136 5 is_stmt 0 view .LVU189
 664 0058 0ED9     		bls	.L48
 665              	.L47:
 666              		.loc 1 137 7 is_stmt 1 discriminator 3 view .LVU190
 667              	.LBB139:
 668              	.LBB134:
  49:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
 669              		.loc 1 49 9 is_stmt 0 discriminator 3 view .LVU191
 670 005a 2B69     		ldr	r3, [r5, #16]
 671 005c 0F19     		adds	r7, r1, r4
 672              	.LVL42:
  49:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
 673              		.loc 1 49 9 discriminator 3 view .LVU192
 674              	.LBE134:
 675              	.LBI130:
  47:source/HvMessagePool.c ****   MessageListNode *n = NULL;
 676              		.loc 1 47 13 is_stmt 1 discriminator 3 view .LVU193
 677              	.LBB135:
  48:source/HvMessagePool.c ****   if (ml->pool != NULL) {
 678              		.loc 1 48 3 discriminator 3 view .LVU194
  49:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
 679              		.loc 1 49 3 discriminator 3 view .LVU195
  49:source/HvMessagePool.c ****     // take an empty MessageListNode from the pool
 680              		.loc 1 49 6 is_stmt 0 discriminator 3 view .LVU196
 681 005e 002B     		cmp	r3, #0
 682 0060 F1D1     		bne	.L58
  55:source/HvMessagePool.c ****     hv_assert(n != NULL);
 683              		.loc 1 55 5 is_stmt 1 view .LVU197
  55:source/HvMessagePool.c ****     hv_assert(n != NULL);
 684              		.loc 1 55 29 is_stmt 0 view .LVU198
 685 0062 0820     		movs	r0, #8
 686 0064 0191     		str	r1, [sp, #4]
 687 0066 FFF7FEFF 		bl	malloc
 688              	.LVL43:
  56:source/HvMessagePool.c ****   }
 689              		.loc 1 56 5 is_stmt 1 view .LVU199
 690 006a 0346     		mov	r3, r0
 691 006c E8B1     		cbz	r0, .L52
 692 006e EE68     		ldr	r6, [r5, #12]
 693 0070 0199     		ldr	r1, [sp, #4]
 694 0072 EAE7     		b	.L46
 695              	.LVL44:
 696              	.L57:
  56:source/HvMessagePool.c ****   }
 697              		.loc 1 56 5 is_stmt 0 view .LVU200
 698              	.LBE135:
 699              	.LBE139:
 700              	.LBE129:
 701              	.LBB141:
 702              	.LBB142:
  41:source/HvMessagePool.c ****   n->p = NULL; // set to NULL to make it clear that this node does not have a valid buffer
 703              		.loc 1 41 15 view .LVU201
 704 0074 D3E90072 		ldrd	r7, r2, [r3]
 705              	.LVL45:
 706              	.L48:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 25


  41:source/HvMessagePool.c ****   n->p = NULL; // set to NULL to make it clear that this node does not have a valid buffer
 707              		.loc 1 41 15 view .LVU202
 708              	.LBE142:
 709              	.LBE141:
 138:source/HvMessagePool.c ****     }
 139:source/HvMessagePool.c ****     mp->bufferIndex = newIndex;
 710              		.loc 1 139 5 is_stmt 1 view .LVU203
 711              		.loc 1 139 21 is_stmt 0 view .LVU204
 712 0078 CAF808B0 		str	fp, [r10, #8]
 140:source/HvMessagePool.c ****     char *buf = ml_pop(ml);
 713              		.loc 1 140 5 is_stmt 1 view .LVU205
 714              	.LVL46:
 715              	.LBB146:
 716              	.LBI141:
  36:source/HvMessagePool.c ****   MessageListNode *n = ml->head;
 717              		.loc 1 36 14 view .LVU206
 718              	.LBB143:
  37:source/HvMessagePool.c ****   ml->head = n->next;
 719              		.loc 1 37 3 view .LVU207
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 720              		.loc 1 38 3 view .LVU208
 721              	.LBE143:
 722              	.LBE146:
 141:source/HvMessagePool.c ****     msg_copyToBuffer(m, buf, chunkSize);
 723              		.loc 1 141 5 is_stmt 0 view .LVU209
 724 007c 4846     		mov	r0, r9
 725              	.LBB147:
 726              	.LBB144:
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 727              		.loc 1 38 12 view .LVU210
 728 007e EA60     		str	r2, [r5, #12]
  39:source/HvMessagePool.c ****   ml->pool = n;
 729              		.loc 1 39 3 is_stmt 1 view .LVU211
 730              	.LBE144:
 731              	.LBE147:
 732              		.loc 1 141 5 is_stmt 0 view .LVU212
 733 0080 4246     		mov	r2, r8
 734              	.LBB148:
 735              	.LBB145:
  39:source/HvMessagePool.c ****   ml->pool = n;
 736              		.loc 1 39 11 view .LVU213
 737 0082 2969     		ldr	r1, [r5, #16]
 738 0084 5960     		str	r1, [r3, #4]
 739              	.LVL47:
 740              	.L54:
  40:source/HvMessagePool.c ****   char *const p = n->p;
 741              		.loc 1 40 3 is_stmt 1 view .LVU214
  42:source/HvMessagePool.c ****   return p;
 742              		.loc 1 42 8 is_stmt 0 view .LVU215
 743 0086 0021     		movs	r1, #0
  40:source/HvMessagePool.c ****   char *const p = n->p;
 744              		.loc 1 40 12 view .LVU216
 745 0088 2B61     		str	r3, [r5, #16]
  41:source/HvMessagePool.c ****   n->p = NULL; // set to NULL to make it clear that this node does not have a valid buffer
 746              		.loc 1 41 3 is_stmt 1 view .LVU217
 747              	.LVL48:
  42:source/HvMessagePool.c ****   return p;
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 26


 748              		.loc 1 42 3 view .LVU218
  42:source/HvMessagePool.c ****   return p;
 749              		.loc 1 42 8 is_stmt 0 view .LVU219
 750 008a 1960     		str	r1, [r3]
  43:source/HvMessagePool.c **** }
 751              		.loc 1 43 3 is_stmt 1 view .LVU220
 752              	.LVL49:
  43:source/HvMessagePool.c **** }
 753              		.loc 1 43 3 is_stmt 0 view .LVU221
 754              	.LBE145:
 755              	.LBE148:
 756              		.loc 1 141 5 is_stmt 1 view .LVU222
 757 008c 3946     		mov	r1, r7
 758 008e FFF7FEFF 		bl	msg_copyToBuffer
 759              	.LVL50:
 142:source/HvMessagePool.c ****     return (HvMessage *) buf;
 760              		.loc 1 142 5 view .LVU223
 761              	.LBE128:
 143:source/HvMessagePool.c ****   }
 144:source/HvMessagePool.c **** }
 762              		.loc 1 144 1 is_stmt 0 view .LVU224
 763 0092 3846     		mov	r0, r7
 764 0094 03B0     		add	sp, sp, #12
 765              		.cfi_remember_state
 766              		.cfi_def_cfa_offset 36
 767              		@ sp needed
 768 0096 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 769              	.LVL51:
 770              	.L56:
 771              		.cfi_restore_state
 772              	.LBB150:
 126:source/HvMessagePool.c ****     msg_copyToBuffer(m, buf, chunkSize);
 773              		.loc 1 126 5 is_stmt 1 view .LVU225
 774              	.LBB151:
 775              	.LBI151:
  36:source/HvMessagePool.c ****   MessageListNode *n = ml->head;
 776              		.loc 1 36 14 view .LVU226
 777              	.LBB152:
  37:source/HvMessagePool.c ****   ml->head = n->next;
 778              		.loc 1 37 3 view .LVU227
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 779              		.loc 1 38 3 view .LVU228
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 780              		.loc 1 38 12 is_stmt 0 view .LVU229
 781 009a 5968     		ldr	r1, [r3, #4]
 782              	.LVL52:
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 783              		.loc 1 38 12 view .LVU230
 784              	.LBE152:
 785              	.LBE151:
 127:source/HvMessagePool.c ****     return (HvMessage *) buf;
 786              		.loc 1 127 5 view .LVU231
 787 009c 4246     		mov	r2, r8
 788              	.LVL53:
 127:source/HvMessagePool.c ****     return (HvMessage *) buf;
 789              		.loc 1 127 5 view .LVU232
 790 009e 4846     		mov	r0, r9
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 27


 791              	.LVL54:
 792              	.LBB154:
 793              	.LBB153:
  41:source/HvMessagePool.c ****   n->p = NULL; // set to NULL to make it clear that this node does not have a valid buffer
 794              		.loc 1 41 15 view .LVU233
 795 00a0 1F68     		ldr	r7, [r3]
  38:source/HvMessagePool.c ****   n->next = ml->pool;
 796              		.loc 1 38 12 view .LVU234
 797 00a2 E960     		str	r1, [r5, #12]
  39:source/HvMessagePool.c ****   ml->pool = n;
 798              		.loc 1 39 3 is_stmt 1 view .LVU235
  39:source/HvMessagePool.c ****   ml->pool = n;
 799              		.loc 1 39 11 is_stmt 0 view .LVU236
 800 00a4 2969     		ldr	r1, [r5, #16]
 801 00a6 5960     		str	r1, [r3, #4]
  40:source/HvMessagePool.c ****   char *const p = n->p;
 802              		.loc 1 40 3 is_stmt 1 view .LVU237
 803 00a8 EDE7     		b	.L54
 804              	.LVL55:
 805              	.L52:
  40:source/HvMessagePool.c ****   char *const p = n->p;
 806              		.loc 1 40 3 is_stmt 0 view .LVU238
 807              	.LBE153:
 808              	.LBE154:
 809              	.LBE150:
 810              	.LBB155:
 811              	.LBB149:
 812              	.LBB140:
 813              	.LBB136:
 814 00aa FFF7FEFF 		bl	ml_push.part.0
 815              	.LVL56:
 816              	.L55:
  40:source/HvMessagePool.c ****   char *const p = n->p;
 817              		.loc 1 40 3 view .LVU239
 818              	.LBE136:
 819              	.LBE140:
 820              	.LBE149:
 821              	.LBE155:
 121:source/HvMessagePool.c ****   HvMessagePoolList *ml = &mp->lists[i];
 822              		.loc 1 121 3 discriminator 1 view .LVU240
 823 00ae 064B     		ldr	r3, .L59
 824              	.LVL57:
 121:source/HvMessagePool.c ****   HvMessagePoolList *ml = &mp->lists[i];
 825              		.loc 1 121 3 discriminator 1 view .LVU241
 826 00b0 7921     		movs	r1, #121
 827              	.LVL58:
 121:source/HvMessagePool.c ****   HvMessagePoolList *ml = &mp->lists[i];
 828              		.loc 1 121 3 discriminator 1 view .LVU242
 829 00b2 064A     		ldr	r2, .L59+4
 830 00b4 0648     		ldr	r0, .L59+8
 831              	.LVL59:
 121:source/HvMessagePool.c ****   HvMessagePoolList *ml = &mp->lists[i];
 832              		.loc 1 121 3 discriminator 1 view .LVU243
 833 00b6 FFF7FEFF 		bl	__assert_func
 834              	.LVL60:
 835              	.L42:
 836              	.LBB156:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 28


 132:source/HvMessagePool.c ****         "The message pool buffer size has been exceeded. The context cannot store more messages. "
 837              		.loc 1 132 5 discriminator 1 view .LVU244
 838 00ba 064B     		ldr	r3, .L59+12
 839 00bc 8421     		movs	r1, #132
 840              	.LVL61:
 132:source/HvMessagePool.c ****         "The message pool buffer size has been exceeded. The context cannot store more messages. "
 841              		.loc 1 132 5 discriminator 1 view .LVU245
 842 00be 034A     		ldr	r2, .L59+4
 843 00c0 0348     		ldr	r0, .L59+8
 844              	.LVL62:
 132:source/HvMessagePool.c ****         "The message pool buffer size has been exceeded. The context cannot store more messages. "
 845              		.loc 1 132 5 discriminator 1 view .LVU246
 846 00c2 FFF7FEFF 		bl	__assert_func
 847              	.LVL63:
 848              	.L60:
 132:source/HvMessagePool.c ****         "The message pool buffer size has been exceeded. The context cannot store more messages. "
 849              		.loc 1 132 5 discriminator 1 view .LVU247
 850 00c6 00BF     		.align	2
 851              	.L59:
 852 00c8 00000000 		.word	.LC3
 853 00cc 00000000 		.word	.LANCHOR2
 854 00d0 14000000 		.word	.LC1
 855 00d4 08000000 		.word	.LC4
 856              	.LBE156:
 857              		.cfi_endproc
 858              	.LFE353:
 860              		.section	.rodata.__func__.0,"a"
 861              		.align	2
 862              		.set	.LANCHOR2,. + 0
 865              	__func__.0:
 866 0000 6D705F61 		.ascii	"mp_addMessage\000"
 866      64644D65 
 866      73736167 
 866      6500
 867              		.section	.rodata.__func__.1,"a"
 868              		.align	2
 869              		.set	.LANCHOR0,. + 0
 872              	__func__.1:
 873 0000 6D6C5F70 		.ascii	"ml_push\000"
 873      75736800 
 874              		.section	.rodata.__func__.2,"a"
 875              		.align	2
 876              		.set	.LANCHOR1,. + 0
 879              	__func__.2:
 880 0000 6D705F69 		.ascii	"mp_init\000"
 880      6E697400 
 881              		.text
 882              	.Letext0:
 883              		.file 4 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/machine/_default_types.h"
 884              		.file 5 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/sys/_stdint.h"
 885              		.file 6 "/Library/DaisyToolchain/0.2.0/arm/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 886              		.file 7 "source/HvMessagePool.h"
 887              		.file 8 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/stdlib.h"
 888              		.file 9 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/assert.h"
 889              		.file 10 "<built-in>"
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s 			page 29


DEFINED SYMBOLS
                            *ABS*:0000000000000000 HvMessagePool.c
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:19     .rodata.ml_push.part.0.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:26     .text.ml_push.part.0:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:32     .text.ml_push.part.0:0000000000000000 ml_push.part.0
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:56     .text.ml_push.part.0:0000000000000010 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:63     .rodata.mp_init.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:67     .text.mp_init:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:74     .text.mp_init:0000000000000000 mp_init
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:145    .text.mp_init:0000000000000038 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:152    .text.mp_free:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:159    .text.mp_free:0000000000000000 mp_free
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:320    .text.mp_freeMessage:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:327    .text.mp_freeMessage:0000000000000000 mp_freeMessage
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:476    .rodata.mp_addMessage.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:487    .text.mp_addMessage:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:494    .text.mp_addMessage:0000000000000000 mp_addMessage
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:852    .text.mp_addMessage:00000000000000c8 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:861    .rodata.__func__.0:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:865    .rodata.__func__.0:0000000000000000 __func__.0
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:868    .rodata.__func__.1:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:872    .rodata.__func__.1:0000000000000000 __func__.1
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:875    .rodata.__func__.2:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccy7FVlC.s:879    .rodata.__func__.2:0000000000000000 __func__.2

UNDEFINED SYMBOLS
__assert_func
malloc
free
memset
msg_copyToBuffer
