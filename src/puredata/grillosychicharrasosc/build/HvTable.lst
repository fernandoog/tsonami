ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 1


   1              		.cpu cortex-m7
   2              		.arch armv7e-m
   3              		.fpu fpv5-d16
   4              		.eabi_attribute 28, 1
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 2
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.file	"HvTable.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata.hTable_init.str1.4,"aMS",%progbits,1
  19              		.align	2
  20              	.LC0:
  21 0000 6F2D3E62 		.ascii	"o->buffer != ((void *)0)\000"
  21      75666665 
  21      7220213D 
  21      20282876 
  21      6F696420 
  22 0019 000000   		.align	2
  23              	.LC1:
  24 001c 736F7572 		.ascii	"source/HvTable.c\000"
  24      63652F48 
  24      76546162 
  24      6C652E63 
  24      00
  25              		.section	.text.hTable_init,"ax",%progbits
  26              		.align	1
  27              		.p2align 2,,3
  28              		.global	hTable_init
  29              		.syntax unified
  30              		.thumb
  31              		.thumb_func
  33              	hTable_init:
  34              	.LVL0:
  35              	.LFB351:
  36              		.file 1 "source/HvTable.c"
   1:source/HvTable.c **** /**
   2:source/HvTable.c ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvTable.c ****  *
   4:source/HvTable.c ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvTable.c ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvTable.c ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvTable.c ****  *
   8:source/HvTable.c ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvTable.c ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvTable.c ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvTable.c ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvTable.c ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvTable.c ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvTable.c ****  * PERFORMANCE OF THIS SOFTWARE.
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 2


  15:source/HvTable.c ****  */
  16:source/HvTable.c **** 
  17:source/HvTable.c **** #include "HvTable.h"
  18:source/HvTable.c **** #include "HvMessage.h"
  19:source/HvTable.c **** 
  20:source/HvTable.c **** hv_size_t hTable_init(HvTable *o, int length) {
  37              		.loc 1 20 47 view -0
  38              		.cfi_startproc
  39              		@ args = 0, pretend = 0, frame = 0
  40              		@ frame_needed = 0, uses_anonymous_args = 0
  21:source/HvTable.c ****   o->length = length;
  41              		.loc 1 21 3 view .LVU1
  20:source/HvTable.c ****   o->length = length;
  42              		.loc 1 20 47 is_stmt 0 view .LVU2
  43 0000 38B5     		push	{r3, r4, r5, lr}
  44              		.cfi_def_cfa_offset 16
  45              		.cfi_offset 3, -16
  46              		.cfi_offset 4, -12
  47              		.cfi_offset 5, -8
  48              		.cfi_offset 14, -4
  20:source/HvTable.c ****   o->length = length;
  49              		.loc 1 20 47 view .LVU3
  50 0002 0B46     		mov	r3, r1
  22:source/HvTable.c ****   // true size of the table is always an integer multple of HV_N_SIMD
  23:source/HvTable.c ****   o->size = (length + HV_N_SIMD_MASK) & ~HV_N_SIMD_MASK;
  24:source/HvTable.c ****   // add an extra length for mirroring
  25:source/HvTable.c ****   o->allocated = o->size + HV_N_SIMD;
  26:source/HvTable.c ****   o->head = 0;
  27:source/HvTable.c ****   hv_size_t numBytes = o->allocated * sizeof(float);
  28:source/HvTable.c ****   o->buffer = (float *) hv_malloc(numBytes);
  51              		.loc 1 28 25 view .LVU4
  52 0004 0121     		movs	r1, #1
  53              	.LVL1:
  26:source/HvTable.c ****   hv_size_t numBytes = o->allocated * sizeof(float);
  54              		.loc 1 26 11 view .LVU5
  55 0006 0025     		movs	r5, #0
  20:source/HvTable.c ****   o->length = length;
  56              		.loc 1 20 47 view .LVU6
  57 0008 0446     		mov	r4, r0
  25:source/HvTable.c ****   o->head = 0;
  58              		.loc 1 25 26 view .LVU7
  59 000a 5A18     		adds	r2, r3, r1
  26:source/HvTable.c ****   hv_size_t numBytes = o->allocated * sizeof(float);
  60              		.loc 1 26 11 view .LVU8
  61 000c 0561     		str	r5, [r0, #16]
  27:source/HvTable.c ****   o->buffer = (float *) hv_malloc(numBytes);
  62              		.loc 1 27 13 view .LVU9
  63 000e 9500     		lsls	r5, r2, #2
  25:source/HvTable.c ****   o->head = 0;
  64              		.loc 1 25 16 view .LVU10
  65 0010 C260     		str	r2, [r0, #12]
  23:source/HvTable.c ****   // add an extra length for mirroring
  66              		.loc 1 23 11 view .LVU11
  67 0012 C0E90133 		strd	r3, r3, [r0, #4]
  25:source/HvTable.c ****   o->head = 0;
  68              		.loc 1 25 3 is_stmt 1 view .LVU12
  26:source/HvTable.c ****   hv_size_t numBytes = o->allocated * sizeof(float);
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 3


  69              		.loc 1 26 3 view .LVU13
  27:source/HvTable.c ****   o->buffer = (float *) hv_malloc(numBytes);
  70              		.loc 1 27 3 view .LVU14
  71              	.LVL2:
  72              		.loc 1 28 3 view .LVU15
  73              		.loc 1 28 25 is_stmt 0 view .LVU16
  74 0016 2846     		mov	r0, r5
  75              	.LVL3:
  76              		.loc 1 28 25 view .LVU17
  77 0018 FFF7FEFF 		bl	calloc
  78              	.LVL4:
  79              		.loc 1 28 13 view .LVU18
  80 001c 2060     		str	r0, [r4]
  29:source/HvTable.c ****   hv_assert(o->buffer != NULL);
  81              		.loc 1 29 3 is_stmt 1 view .LVU19
  82 001e 08B1     		cbz	r0, .L5
  30:source/HvTable.c ****   hv_memclear(o->buffer, numBytes);
  31:source/HvTable.c ****   return numBytes;
  32:source/HvTable.c **** }
  83              		.loc 1 32 1 is_stmt 0 view .LVU20
  84 0020 2846     		mov	r0, r5
  85 0022 38BD     		pop	{r3, r4, r5, pc}
  86              	.LVL5:
  87              	.L5:
  29:source/HvTable.c ****   hv_assert(o->buffer != NULL);
  88              		.loc 1 29 3 discriminator 1 view .LVU21
  89 0024 024B     		ldr	r3, .L6
  90 0026 1D21     		movs	r1, #29
  91 0028 024A     		ldr	r2, .L6+4
  92 002a 0348     		ldr	r0, .L6+8
  93 002c FFF7FEFF 		bl	__assert_func
  94              	.LVL6:
  95              	.L7:
  96              		.align	2
  97              	.L6:
  98 0030 00000000 		.word	.LC0
  99 0034 00000000 		.word	.LANCHOR0
 100 0038 1C000000 		.word	.LC1
 101              		.cfi_endproc
 102              	.LFE351:
 104              		.section	.text.hTable_initWithData,"ax",%progbits
 105              		.align	1
 106              		.p2align 2,,3
 107              		.global	hTable_initWithData
 108              		.syntax unified
 109              		.thumb
 110              		.thumb_func
 112              	hTable_initWithData:
 113              	.LVL7:
 114              	.LFB352:
  33:source/HvTable.c **** 
  34:source/HvTable.c **** hv_size_t hTable_initWithData(HvTable *o, int length, const float *data) {
 115              		.loc 1 34 74 is_stmt 1 view -0
 116              		.cfi_startproc
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
  35:source/HvTable.c ****   o->length = length;
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 4


 119              		.loc 1 35 3 view .LVU23
  34:source/HvTable.c ****   o->length = length;
 120              		.loc 1 34 74 is_stmt 0 view .LVU24
 121 0000 0B46     		mov	r3, r1
  36:source/HvTable.c ****   o->size = (length + HV_N_SIMD_MASK) & ~HV_N_SIMD_MASK;
  37:source/HvTable.c ****   o->allocated = o->size + HV_N_SIMD;
  38:source/HvTable.c ****   o->head = 0;
  39:source/HvTable.c ****   hv_size_t numBytes = o->size * sizeof(float);
  40:source/HvTable.c ****   o->buffer = (float *) hv_malloc(numBytes);
 122              		.loc 1 40 25 view .LVU25
 123 0002 0121     		movs	r1, #1
 124              	.LVL8:
  34:source/HvTable.c ****   o->length = length;
 125              		.loc 1 34 74 view .LVU26
 126 0004 70B5     		push	{r4, r5, r6, lr}
 127              		.cfi_def_cfa_offset 16
 128              		.cfi_offset 4, -16
 129              		.cfi_offset 5, -12
 130              		.cfi_offset 6, -8
 131              		.cfi_offset 14, -4
  38:source/HvTable.c ****   hv_size_t numBytes = o->size * sizeof(float);
 132              		.loc 1 38 11 view .LVU27
 133 0006 0024     		movs	r4, #0
  34:source/HvTable.c ****   o->length = length;
 134              		.loc 1 34 74 view .LVU28
 135 0008 1646     		mov	r6, r2
  37:source/HvTable.c ****   o->head = 0;
 136              		.loc 1 37 26 view .LVU29
 137 000a 5A18     		adds	r2, r3, r1
 138              	.LVL9:
  34:source/HvTable.c ****   o->length = length;
 139              		.loc 1 34 74 view .LVU30
 140 000c 0546     		mov	r5, r0
  37:source/HvTable.c ****   o->head = 0;
 141              		.loc 1 37 16 view .LVU31
 142 000e C0E90324 		strd	r2, r4, [r0, #12]
  39:source/HvTable.c ****   o->buffer = (float *) hv_malloc(numBytes);
 143              		.loc 1 39 13 view .LVU32
 144 0012 9C00     		lsls	r4, r3, #2
  36:source/HvTable.c ****   o->allocated = o->size + HV_N_SIMD;
 145              		.loc 1 36 11 view .LVU33
 146 0014 C0E90133 		strd	r3, r3, [r0, #4]
  37:source/HvTable.c ****   o->head = 0;
 147              		.loc 1 37 3 is_stmt 1 view .LVU34
  38:source/HvTable.c ****   hv_size_t numBytes = o->size * sizeof(float);
 148              		.loc 1 38 3 view .LVU35
  39:source/HvTable.c ****   o->buffer = (float *) hv_malloc(numBytes);
 149              		.loc 1 39 3 view .LVU36
 150              	.LVL10:
 151              		.loc 1 40 3 view .LVU37
 152              		.loc 1 40 25 is_stmt 0 view .LVU38
 153 0018 2046     		mov	r0, r4
 154              	.LVL11:
 155              		.loc 1 40 25 view .LVU39
 156 001a FFF7FEFF 		bl	calloc
 157              	.LVL12:
 158              		.loc 1 40 13 view .LVU40
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 5


 159 001e 2860     		str	r0, [r5]
  41:source/HvTable.c ****   hv_assert(o->buffer != NULL);
 160              		.loc 1 41 3 is_stmt 1 view .LVU41
 161 0020 28B1     		cbz	r0, .L11
  42:source/HvTable.c ****   hv_memclear(o->buffer, numBytes);
 162              		.loc 1 42 3 view .LVU42
  43:source/HvTable.c ****   hv_memcpy(o->buffer, data, length*sizeof(float));
 163              		.loc 1 43 3 view .LVU43
 164 0022 2246     		mov	r2, r4
 165 0024 3146     		mov	r1, r6
 166 0026 FFF7FEFF 		bl	memcpy
 167              	.LVL13:
  44:source/HvTable.c ****   return numBytes;
 168              		.loc 1 44 3 view .LVU44
  45:source/HvTable.c **** }
 169              		.loc 1 45 1 is_stmt 0 view .LVU45
 170 002a 2046     		mov	r0, r4
 171 002c 70BD     		pop	{r4, r5, r6, pc}
 172              	.LVL14:
 173              	.L11:
  41:source/HvTable.c ****   hv_memclear(o->buffer, numBytes);
 174              		.loc 1 41 3 discriminator 1 view .LVU46
 175 002e 034B     		ldr	r3, .L12
 176 0030 2921     		movs	r1, #41
 177 0032 034A     		ldr	r2, .L12+4
 178 0034 0348     		ldr	r0, .L12+8
 179 0036 FFF7FEFF 		bl	__assert_func
 180              	.LVL15:
 181              	.L13:
 182 003a 00BF     		.align	2
 183              	.L12:
 184 003c 00000000 		.word	.LC0
 185 0040 00000000 		.word	.LANCHOR1
 186 0044 1C000000 		.word	.LC1
 187              		.cfi_endproc
 188              	.LFE352:
 190              		.section	.text.hTable_initWithFinalData,"ax",%progbits
 191              		.align	1
 192              		.p2align 2,,3
 193              		.global	hTable_initWithFinalData
 194              		.syntax unified
 195              		.thumb
 196              		.thumb_func
 198              	hTable_initWithFinalData:
 199              	.LVL16:
 200              	.LFB353:
  46:source/HvTable.c **** 
  47:source/HvTable.c **** hv_size_t hTable_initWithFinalData(HvTable *o, int length, float *data) {
 201              		.loc 1 47 73 is_stmt 1 view -0
 202              		.cfi_startproc
 203              		@ args = 0, pretend = 0, frame = 0
 204              		@ frame_needed = 0, uses_anonymous_args = 0
 205              		@ link register save eliminated.
  48:source/HvTable.c ****   o->length = length;
 206              		.loc 1 48 3 view .LVU48
  47:source/HvTable.c ****   o->length = length;
 207              		.loc 1 47 73 is_stmt 0 view .LVU49
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 6


 208 0000 10B4     		push	{r4}
 209              		.cfi_def_cfa_offset 4
 210              		.cfi_offset 4, -4
  47:source/HvTable.c ****   o->length = length;
 211              		.loc 1 47 73 view .LVU50
 212 0002 0346     		mov	r3, r0
  49:source/HvTable.c ****   o->size = length;
  50:source/HvTable.c ****   o->allocated = length;
  51:source/HvTable.c ****   o->buffer = data;
  52:source/HvTable.c ****   o->head = 0;
 213              		.loc 1 52 11 view .LVU51
 214 0004 0024     		movs	r4, #0
  49:source/HvTable.c ****   o->size = length;
 215              		.loc 1 49 11 view .LVU52
 216 0006 C3E90111 		strd	r1, r1, [r3, #4]
  50:source/HvTable.c ****   o->buffer = data;
 217              		.loc 1 50 3 is_stmt 1 view .LVU53
  53:source/HvTable.c ****   return 0;
  54:source/HvTable.c **** }
 218              		.loc 1 54 1 is_stmt 0 view .LVU54
 219 000a 2046     		mov	r0, r4
 220              	.LVL17:
  52:source/HvTable.c ****   return 0;
 221              		.loc 1 52 11 view .LVU55
 222 000c 1C61     		str	r4, [r3, #16]
  50:source/HvTable.c ****   o->buffer = data;
 223              		.loc 1 50 16 view .LVU56
 224 000e D960     		str	r1, [r3, #12]
  51:source/HvTable.c ****   o->head = 0;
 225              		.loc 1 51 3 is_stmt 1 view .LVU57
 226              		.loc 1 54 1 is_stmt 0 view .LVU58
 227 0010 5DF8044B 		ldr	r4, [sp], #4
 228              		.cfi_restore 4
 229              		.cfi_def_cfa_offset 0
  51:source/HvTable.c ****   o->head = 0;
 230              		.loc 1 51 13 view .LVU59
 231 0014 1A60     		str	r2, [r3]
  52:source/HvTable.c ****   return 0;
 232              		.loc 1 52 3 is_stmt 1 view .LVU60
  53:source/HvTable.c ****   return 0;
 233              		.loc 1 53 3 view .LVU61
 234              		.loc 1 54 1 is_stmt 0 view .LVU62
 235 0016 7047     		bx	lr
 236              		.cfi_endproc
 237              	.LFE353:
 239              		.section	.text.hTable_free,"ax",%progbits
 240              		.align	1
 241              		.p2align 2,,3
 242              		.global	hTable_free
 243              		.syntax unified
 244              		.thumb
 245              		.thumb_func
 247              	hTable_free:
 248              	.LVL18:
 249              	.LFB354:
  55:source/HvTable.c **** 
  56:source/HvTable.c **** void hTable_free(HvTable *o) {
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 7


 250              		.loc 1 56 30 is_stmt 1 view -0
 251              		.cfi_startproc
 252              		@ args = 0, pretend = 0, frame = 0
 253              		@ frame_needed = 0, uses_anonymous_args = 0
 254              		@ link register save eliminated.
  57:source/HvTable.c ****   hv_free(o->buffer);
 255              		.loc 1 57 3 view .LVU64
 256 0000 0068     		ldr	r0, [r0]
 257              	.LVL19:
 258              		.loc 1 57 3 is_stmt 0 view .LVU65
 259 0002 FFF7FEBF 		b	free
 260              	.LVL20:
 261              		.cfi_endproc
 262              	.LFE354:
 264 0006 00BF     		.section	.rodata.hTable_resize.str1.4,"aMS",%progbits,1
 265              		.align	2
 266              	.LC2:
 267 0000 6220213D 		.ascii	"b != ((void *)0)\000"
 267      20282876 
 267      6F696420 
 267      2A293029 
 267      00
 268              		.section	.text.hTable_resize,"ax",%progbits
 269              		.align	1
 270              		.p2align 2,,3
 271              		.global	hTable_resize
 272              		.syntax unified
 273              		.thumb
 274              		.thumb_func
 276              	hTable_resize:
 277              	.LVL21:
 278              	.LFB355:
  58:source/HvTable.c **** }
  59:source/HvTable.c **** 
  60:source/HvTable.c **** int hTable_resize(HvTable *o, hv_uint32_t newLength) {
 279              		.loc 1 60 54 is_stmt 1 view -0
 280              		.cfi_startproc
 281              		@ args = 0, pretend = 0, frame = 0
 282              		@ frame_needed = 0, uses_anonymous_args = 0
  61:source/HvTable.c ****   // TODO(mhroth): update context with memory allocated by table
  62:source/HvTable.c ****   // NOTE(mhroth): mirrored bytes are not necessarily carried over
  63:source/HvTable.c ****   const hv_uint32_t newSize = (newLength + HV_N_SIMD_MASK) & ~HV_N_SIMD_MASK;
 283              		.loc 1 63 3 view .LVU67
  64:source/HvTable.c ****   if (newSize == o->size) return 0; // early exit if no change in size
 284              		.loc 1 64 3 view .LVU68
  60:source/HvTable.c ****   // TODO(mhroth): update context with memory allocated by table
 285              		.loc 1 60 54 is_stmt 0 view .LVU69
 286 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 287              		.cfi_def_cfa_offset 24
 288              		.cfi_offset 4, -24
 289              		.cfi_offset 5, -20
 290              		.cfi_offset 6, -16
 291              		.cfi_offset 7, -12
 292              		.cfi_offset 8, -8
 293              		.cfi_offset 14, -4
 294              		.loc 1 64 19 view .LVU70
 295 0004 8568     		ldr	r5, [r0, #8]
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 8


 296              		.loc 1 64 6 view .LVU71
 297 0006 8D42     		cmp	r5, r1
 298 0008 21D0     		beq	.L21
  65:source/HvTable.c ****   const hv_uint32_t oldSizeBytes = (hv_uint32_t) (o->size * sizeof(float));
 299              		.loc 1 65 3 is_stmt 1 view .LVU72
  66:source/HvTable.c ****   const hv_uint32_t newAllocated = newSize + HV_N_SIMD;
 300              		.loc 1 66 21 is_stmt 0 view .LVU73
 301 000a 01F10108 		add	r8, r1, #1
 302 000e 0446     		mov	r4, r0
 303 0010 0E46     		mov	r6, r1
  67:source/HvTable.c ****   const hv_uint32_t newAllocatedBytes = (hv_uint32_t) (newAllocated * sizeof(float));
  68:source/HvTable.c **** 
  69:source/HvTable.c ****   float *b = (float *) hv_realloc(o->buffer, newAllocatedBytes);
 304              		.loc 1 69 24 view .LVU74
 305 0012 0068     		ldr	r0, [r0]
 306              	.LVL22:
 307              		.loc 1 69 24 view .LVU75
 308 0014 4FEA8801 		lsl	r1, r8, #2
 309              	.LVL23:
 310              		.loc 1 69 24 view .LVU76
 311 0018 FFF7FEFF 		bl	realloc
 312              	.LVL24:
  70:source/HvTable.c ****   hv_assert(b != NULL); // error while reallocing!
 313              		.loc 1 70 3 view .LVU77
 314 001c 0746     		mov	r7, r0
  65:source/HvTable.c ****   const hv_uint32_t newAllocated = newSize + HV_N_SIMD;
 315              		.loc 1 65 21 view .LVU78
 316 001e AD00     		lsls	r5, r5, #2
 317              	.LVL25:
  66:source/HvTable.c ****   const hv_uint32_t newAllocatedBytes = (hv_uint32_t) (newAllocated * sizeof(float));
 318              		.loc 1 66 3 is_stmt 1 view .LVU79
  67:source/HvTable.c **** 
 319              		.loc 1 67 3 view .LVU80
  69:source/HvTable.c ****   hv_assert(b != NULL); // error while reallocing!
 320              		.loc 1 69 3 view .LVU81
 321              		.loc 1 70 3 view .LVU82
 322 0020 C0B1     		cbz	r0, .L23
  71:source/HvTable.c ****   // ensure that hv_realloc has given us a correctly aligned buffer
  72:source/HvTable.c ****   if ((((hv_uintptr_t) (const void *) b) & ((0x1<<HV_N_SIMD)-1)) == 0) {
 323              		.loc 1 72 3 view .LVU83
  73:source/HvTable.c ****     if (newSize > o->size) {
 324              		.loc 1 73 5 view .LVU84
 325              		.loc 1 73 20 is_stmt 0 view .LVU85
 326 0022 A068     		ldr	r0, [r4, #8]
 327              	.LVL26:
 328              		.loc 1 73 8 view .LVU86
 329 0024 B042     		cmp	r0, r6
 330 0026 09D3     		bcc	.L24
 331              	.L20:
  74:source/HvTable.c ****       hv_memclear(b + o->size, (newAllocated - o->size) * sizeof(float)); // clear new parts of the
  75:source/HvTable.c ****     }
  76:source/HvTable.c ****     o->buffer = b;
 332              		.loc 1 76 5 is_stmt 1 view .LVU87
  77:source/HvTable.c ****   } else {
  78:source/HvTable.c ****     // if not, we have to re-malloc ourselves
  79:source/HvTable.c ****     char *c = (char *) hv_malloc(newAllocatedBytes);
  80:source/HvTable.c ****     hv_assert(c != NULL); // error while allocating new buffer!
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 9


  81:source/HvTable.c ****     if (newAllocatedBytes > oldSizeBytes) {
  82:source/HvTable.c ****       hv_memcpy(c, b, oldSizeBytes);
  83:source/HvTable.c ****       hv_memclear(c + oldSizeBytes, newAllocatedBytes - oldSizeBytes);
  84:source/HvTable.c ****     } else {
  85:source/HvTable.c ****       hv_memcpy(c, b, newAllocatedBytes);
  86:source/HvTable.c ****     }
  87:source/HvTable.c ****     hv_free(b);
  88:source/HvTable.c ****     o->buffer = (float *) c;
  89:source/HvTable.c ****   }
  90:source/HvTable.c ****   o->length = newLength;
  91:source/HvTable.c ****   o->size = newSize;
  92:source/HvTable.c ****   o->allocated = newAllocated;
  93:source/HvTable.c ****   return (int) (newAllocated - oldSizeBytes - (HV_N_SIMD*sizeof(float)));
 333              		.loc 1 93 30 is_stmt 0 view .LVU88
 334 0028 A8EB0505 		sub	r5, r8, r5
 335              	.LVL27:
  91:source/HvTable.c ****   o->allocated = newAllocated;
 336              		.loc 1 91 11 view .LVU89
 337 002c A660     		str	r6, [r4, #8]
  92:source/HvTable.c ****   return (int) (newAllocated - oldSizeBytes - (HV_N_SIMD*sizeof(float)));
 338              		.loc 1 92 16 view .LVU90
 339 002e C4F80C80 		str	r8, [r4, #12]
 340              		.loc 1 93 45 view .LVU91
 341 0032 281F     		subs	r0, r5, #4
  90:source/HvTable.c ****   o->size = newSize;
 342              		.loc 1 90 13 view .LVU92
 343 0034 C4E90076 		strd	r7, r6, [r4]
  91:source/HvTable.c ****   o->allocated = newAllocated;
 344              		.loc 1 91 3 is_stmt 1 view .LVU93
  92:source/HvTable.c ****   return (int) (newAllocated - oldSizeBytes - (HV_N_SIMD*sizeof(float)));
 345              		.loc 1 92 3 view .LVU94
 346              		.loc 1 93 3 view .LVU95
  94:source/HvTable.c **** }
 347              		.loc 1 94 1 is_stmt 0 view .LVU96
 348 0038 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 349              	.LVL28:
 350              	.L24:
  74:source/HvTable.c ****     }
 351              		.loc 1 74 7 is_stmt 1 view .LVU97
 352 003c A8EB0002 		sub	r2, r8, r0
 353 0040 0021     		movs	r1, #0
 354 0042 07EB8000 		add	r0, r7, r0, lsl #2
 355 0046 9200     		lsls	r2, r2, #2
 356 0048 FFF7FEFF 		bl	memset
 357              	.LVL29:
 358 004c ECE7     		b	.L20
 359              	.LVL30:
 360              	.L21:
  64:source/HvTable.c ****   const hv_uint32_t oldSizeBytes = (hv_uint32_t) (o->size * sizeof(float));
 361              		.loc 1 64 34 is_stmt 0 view .LVU98
 362 004e 0020     		movs	r0, #0
 363              	.LVL31:
 364              		.loc 1 94 1 view .LVU99
 365 0050 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 366              	.LVL32:
 367              	.L23:
  70:source/HvTable.c ****   // ensure that hv_realloc has given us a correctly aligned buffer
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 10


 368              		.loc 1 70 3 discriminator 1 view .LVU100
 369 0054 024B     		ldr	r3, .L25
 370 0056 4621     		movs	r1, #70
 371 0058 024A     		ldr	r2, .L25+4
 372 005a 0348     		ldr	r0, .L25+8
 373              	.LVL33:
  70:source/HvTable.c ****   // ensure that hv_realloc has given us a correctly aligned buffer
 374              		.loc 1 70 3 discriminator 1 view .LVU101
 375 005c FFF7FEFF 		bl	__assert_func
 376              	.LVL34:
 377              	.L26:
 378              		.align	2
 379              	.L25:
 380 0060 00000000 		.word	.LC2
 381 0064 00000000 		.word	.LANCHOR2
 382 0068 1C000000 		.word	.LC1
 383              		.cfi_endproc
 384              	.LFE355:
 386              		.section	.rodata.hTable_onMessage.str1.4,"aMS",%progbits,1
 387              		.align	2
 388              	.LC3:
 389 0000 72657369 		.ascii	"resize\000"
 389      7A6500
 390 0007 00       		.align	2
 391              	.LC4:
 392 0008 6D697272 		.ascii	"mirror\000"
 392      6F7200
 393              		.section	.text.hTable_onMessage,"ax",%progbits
 394              		.align	1
 395              		.p2align 2,,3
 396              		.global	hTable_onMessage
 397              		.syntax unified
 398              		.thumb
 399              		.thumb_func
 401              	hTable_onMessage:
 402              	.LVL35:
 403              	.LFB356:
  95:source/HvTable.c **** 
  96:source/HvTable.c **** void hTable_onMessage(HeavyContextInterface *_c, HvTable *o, int letIn, const HvMessage *m,
  97:source/HvTable.c ****     void (*sendMessage)(HeavyContextInterface *, int, const HvMessage *)) {
 404              		.loc 1 97 75 is_stmt 1 view -0
 405              		.cfi_startproc
 406              		@ args = 4, pretend = 0, frame = 8
 407              		@ frame_needed = 1, uses_anonymous_args = 0
  98:source/HvTable.c ****   if (msg_compareSymbol(m,0,"resize") && msg_isFloat(m,1) && msg_getFloat(m,1) >= 0.0f) {
 408              		.loc 1 98 3 view .LVU103
  97:source/HvTable.c ****   if (msg_compareSymbol(m,0,"resize") && msg_isFloat(m,1) && msg_getFloat(m,1) >= 0.0f) {
 409              		.loc 1 97 75 is_stmt 0 view .LVU104
 410 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 411              		.cfi_def_cfa_offset 20
 412              		.cfi_offset 4, -20
 413              		.cfi_offset 5, -16
 414              		.cfi_offset 6, -12
 415              		.cfi_offset 7, -8
 416              		.cfi_offset 14, -4
 417 0002 83B0     		sub	sp, sp, #12
 418              		.cfi_def_cfa_offset 32
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 11


 419 0004 0D46     		mov	r5, r1
 420 0006 0646     		mov	r6, r0
 421              		.loc 1 98 7 view .LVU105
 422 0008 1F4A     		ldr	r2, .L40
 423              	.LVL36:
  97:source/HvTable.c ****   if (msg_compareSymbol(m,0,"resize") && msg_isFloat(m,1) && msg_getFloat(m,1) >= 0.0f) {
 424              		.loc 1 97 75 view .LVU106
 425              		.loc 1 98 7 view .LVU107
 426 000a 0021     		movs	r1, #0
 427              	.LVL37:
  97:source/HvTable.c ****   if (msg_compareSymbol(m,0,"resize") && msg_isFloat(m,1) && msg_getFloat(m,1) >= 0.0f) {
 428              		.loc 1 97 75 view .LVU108
 429 000c 00AF     		add	r7, sp, #0
 430              		.cfi_def_cfa_register 7
 431              		.loc 1 98 7 view .LVU109
 432 000e 1846     		mov	r0, r3
 433              	.LVL38:
  97:source/HvTable.c ****   if (msg_compareSymbol(m,0,"resize") && msg_isFloat(m,1) && msg_getFloat(m,1) >= 0.0f) {
 434              		.loc 1 97 75 view .LVU110
 435 0010 1C46     		mov	r4, r3
 436              		.loc 1 98 7 view .LVU111
 437 0012 FFF7FEFF 		bl	msg_compareSymbol
 438              	.LVL39:
 439              		.loc 1 98 6 view .LVU112
 440 0016 10B1     		cbz	r0, .L28
 441              	.LVL40:
 442              	.LBB50:
 443              	.LBI50:
 444              		.file 2 "source/HvMessage.h"
   1:source/HvMessage.h **** /**
   2:source/HvMessage.h ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvMessage.h ****  *
   4:source/HvMessage.h ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvMessage.h ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvMessage.h ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvMessage.h ****  *
   8:source/HvMessage.h ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvMessage.h ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvMessage.h ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvMessage.h ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvMessage.h ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvMessage.h ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvMessage.h ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvMessage.h ****  */
  16:source/HvMessage.h **** 
  17:source/HvMessage.h **** #ifndef _HEAVY_MESSAGE_H_
  18:source/HvMessage.h **** #define _HEAVY_MESSAGE_H_
  19:source/HvMessage.h **** 
  20:source/HvMessage.h **** #include "HvUtils.h"
  21:source/HvMessage.h **** 
  22:source/HvMessage.h **** #ifdef __cplusplus
  23:source/HvMessage.h **** extern "C" {
  24:source/HvMessage.h **** #endif
  25:source/HvMessage.h **** 
  26:source/HvMessage.h **** typedef enum ElementType {
  27:source/HvMessage.h ****   HV_MSG_BANG = 0,
  28:source/HvMessage.h ****   HV_MSG_FLOAT = 1,
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 12


  29:source/HvMessage.h ****   HV_MSG_SYMBOL = 2,
  30:source/HvMessage.h ****   HV_MSG_HASH = 3
  31:source/HvMessage.h **** } ElementType;
  32:source/HvMessage.h **** 
  33:source/HvMessage.h **** typedef struct Element {
  34:source/HvMessage.h ****   ElementType type;
  35:source/HvMessage.h ****   union {
  36:source/HvMessage.h ****     float f; // float
  37:source/HvMessage.h ****     const char *s; // symbol
  38:source/HvMessage.h ****     hv_uint32_t h; // hash
  39:source/HvMessage.h ****   } data;
  40:source/HvMessage.h **** } Element;
  41:source/HvMessage.h **** 
  42:source/HvMessage.h **** typedef struct HvMessage {
  43:source/HvMessage.h ****   hv_uint32_t timestamp; // the sample at which this message should be processed
  44:source/HvMessage.h ****   hv_uint16_t numElements;
  45:source/HvMessage.h ****   hv_uint16_t numBytes; // the total number of bytes that this message occupies in memory, includin
  46:source/HvMessage.h ****   Element elem;
  47:source/HvMessage.h **** } HvMessage;
  48:source/HvMessage.h **** 
  49:source/HvMessage.h **** typedef struct ReceiverMessagePair {
  50:source/HvMessage.h ****   hv_uint32_t receiverHash;
  51:source/HvMessage.h ****   HvMessage msg;
  52:source/HvMessage.h **** } ReceiverMessagePair;
  53:source/HvMessage.h **** 
  54:source/HvMessage.h **** #define HV_MESSAGE_ON_STACK(_x) (HvMessage *) hv_alloca(msg_getCoreSize(_x))
  55:source/HvMessage.h **** 
  56:source/HvMessage.h **** /** Returns the number of bytes that this message consumes in memory, not including strings. */
  57:source/HvMessage.h **** static inline hv_size_t msg_getCoreSize(hv_size_t numElements) {
  58:source/HvMessage.h ****   hv_assert(numElements > 0);
  59:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
  60:source/HvMessage.h **** }
  61:source/HvMessage.h **** 
  62:source/HvMessage.h **** HvMessage *msg_copy(const HvMessage *m);
  63:source/HvMessage.h **** 
  64:source/HvMessage.h **** /** Copies the message into the given buffer. The buffer must be at least as large as msg_getNumHea
  65:source/HvMessage.h **** void msg_copyToBuffer(const HvMessage *m, char *buffer, hv_size_t len);
  66:source/HvMessage.h **** 
  67:source/HvMessage.h **** void msg_setElementToFrom(HvMessage *n, int indexN, const HvMessage *const m, int indexM);
  68:source/HvMessage.h **** 
  69:source/HvMessage.h **** /** Frees a message on the heap. Does nothing if argument is NULL. */
  70:source/HvMessage.h **** void msg_free(HvMessage *m);
  71:source/HvMessage.h **** 
  72:source/HvMessage.h **** HvMessage *msg_init(HvMessage *m, hv_size_t numElements, hv_uint32_t timestamp);
  73:source/HvMessage.h **** 
  74:source/HvMessage.h **** HvMessage *msg_initWithFloat(HvMessage *m, hv_uint32_t timestamp, float f);
  75:source/HvMessage.h **** 
  76:source/HvMessage.h **** HvMessage *msg_initWithBang(HvMessage *m, hv_uint32_t timestamp);
  77:source/HvMessage.h **** 
  78:source/HvMessage.h **** HvMessage *msg_initWithSymbol(HvMessage *m, hv_uint32_t timestamp, const char *s);
  79:source/HvMessage.h **** 
  80:source/HvMessage.h **** HvMessage *msg_initWithHash(HvMessage *m, hv_uint32_t timestamp, hv_uint32_t h);
  81:source/HvMessage.h **** 
  82:source/HvMessage.h **** static inline hv_uint32_t msg_getTimestamp(const HvMessage *m) {
  83:source/HvMessage.h ****   return m->timestamp;
  84:source/HvMessage.h **** }
  85:source/HvMessage.h **** 
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 13


  86:source/HvMessage.h **** static inline void msg_setTimestamp(HvMessage *m, hv_uint32_t timestamp) {
  87:source/HvMessage.h ****   m->timestamp = timestamp;
  88:source/HvMessage.h **** }
  89:source/HvMessage.h **** 
  90:source/HvMessage.h **** static inline int msg_getNumElements(const HvMessage *m) {
  91:source/HvMessage.h ****   return (int) m->numElements;
  92:source/HvMessage.h **** }
  93:source/HvMessage.h **** 
  94:source/HvMessage.h **** /** Returns the total number of bytes this message consumes in memory. */
  95:source/HvMessage.h **** static inline hv_uint32_t msg_getSize(const HvMessage *m) {
  96:source/HvMessage.h ****   return m->numBytes;
  97:source/HvMessage.h **** }
  98:source/HvMessage.h **** 
  99:source/HvMessage.h **** static inline ElementType msg_getType(const HvMessage *m, int index) {
 100:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 101:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 102:source/HvMessage.h **** }
 103:source/HvMessage.h **** 
 104:source/HvMessage.h **** static inline void msg_setBang(HvMessage *m, int index) {
 105:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 106:source/HvMessage.h ****   (&(m->elem)+index)->type = HV_MSG_BANG;
 107:source/HvMessage.h ****   (&(m->elem)+index)->data.s = NULL;
 108:source/HvMessage.h **** }
 109:source/HvMessage.h **** 
 110:source/HvMessage.h **** static inline bool msg_isBang(const HvMessage *m, int index) {
 111:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_BANG) : false;
 112:source/HvMessage.h **** }
 113:source/HvMessage.h **** 
 114:source/HvMessage.h **** static inline void msg_setFloat(HvMessage *m, int index, float f) {
 115:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 116:source/HvMessage.h ****   (&(m->elem)+index)->type = HV_MSG_FLOAT;
 117:source/HvMessage.h ****   (&(m->elem)+index)->data.f = f;
 118:source/HvMessage.h **** }
 119:source/HvMessage.h **** 
 120:source/HvMessage.h **** static inline float msg_getFloat(const HvMessage *const m, int index) {
 121:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 122:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 123:source/HvMessage.h **** }
 124:source/HvMessage.h **** 
 125:source/HvMessage.h **** static inline bool msg_isFloat(const HvMessage *const m, int index) {
 445              		.loc 2 125 20 is_stmt 1 view .LVU113
 446              	.LBB51:
 126:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_FLOAT) : false;
 447              		.loc 2 126 3 view .LVU114
 448              	.LBB52:
 449              	.LBI52:
  90:source/HvMessage.h ****   return (int) m->numElements;
 450              		.loc 2 90 19 view .LVU115
 451              	.LBB53:
  91:source/HvMessage.h **** }
 452              		.loc 2 91 3 view .LVU116
  91:source/HvMessage.h **** }
 453              		.loc 2 91 3 is_stmt 0 view .LVU117
 454              	.LBE53:
 455              	.LBE52:
 456              		.loc 2 126 83 view .LVU118
 457 0018 A388     		ldrh	r3, [r4, #4]
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 14


 458 001a 012B     		cmp	r3, #1
 459 001c 0DD8     		bhi	.L39
 460              	.LVL41:
 461              	.L28:
 462              		.loc 2 126 83 view .LVU119
 463              	.LBE51:
 464              	.LBE50:
  99:source/HvTable.c ****     hTable_resize(o, (int) hv_ceil_f(msg_getFloat(m,1))); // apply ceil to ensure that tables alway
 100:source/HvTable.c **** 
 101:source/HvTable.c ****     // send out the new size of the table
 102:source/HvTable.c ****     HvMessage *n = HV_MESSAGE_ON_STACK(1);
 103:source/HvTable.c ****     msg_initWithFloat(n, msg_getTimestamp(m), (float) hTable_getSize(o));
 104:source/HvTable.c ****     sendMessage(_c, 0, n);
 105:source/HvTable.c ****   }
 106:source/HvTable.c **** 
 107:source/HvTable.c ****   else if (msg_compareSymbol(m,0,"mirror")) {
 465              		.loc 1 107 8 is_stmt 1 view .LVU120
 466              		.loc 1 107 12 is_stmt 0 view .LVU121
 467 001e 1B4A     		ldr	r2, .L40+4
 468 0020 0021     		movs	r1, #0
 469 0022 2046     		mov	r0, r4
 470 0024 FFF7FEFF 		bl	msg_compareSymbol
 471              	.LVL42:
 472              		.loc 1 107 11 view .LVU122
 473 0028 20B1     		cbz	r0, .L27
 108:source/HvTable.c ****     hv_memcpy(o->buffer+o->size, o->buffer, HV_N_SIMD*sizeof(float));
 474              		.loc 1 108 5 is_stmt 1 view .LVU123
 475 002a 2B68     		ldr	r3, [r5]
 476 002c AA68     		ldr	r2, [r5, #8]
 477 002e 1968     		ldr	r1, [r3]	@ unaligned
 478 0030 43F82210 		str	r1, [r3, r2, lsl #2]	@ unaligned
 479              	.L27:
 109:source/HvTable.c ****   }
 110:source/HvTable.c **** }
 480              		.loc 1 110 1 is_stmt 0 view .LVU124
 481 0034 0C37     		adds	r7, r7, #12
 482              		.cfi_remember_state
 483              		.cfi_def_cfa_offset 20
 484 0036 BD46     		mov	sp, r7
 485              		.cfi_def_cfa_register 13
 486              		@ sp needed
 487 0038 F0BD     		pop	{r4, r5, r6, r7, pc}
 488              	.LVL43:
 489              	.L39:
 490              		.cfi_restore_state
 491              	.LBB60:
 492              	.LBB58:
 493              	.LBB54:
 494              	.LBI54:
  99:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 495              		.loc 2 99 27 is_stmt 1 view .LVU125
 496              	.LBB55:
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 497              		.loc 2 100 3 view .LVU126
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 498              		.loc 2 100 3 is_stmt 0 view .LVU127
 499              	.LBE55:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 15


 500              	.LBE54:
 501              	.LBE58:
 502              	.LBE60:
  91:source/HvMessage.h **** }
 503              		.loc 2 91 3 is_stmt 1 view .LVU128
 504              	.LBB61:
 505              	.LBB59:
 506              	.LBB57:
 507              	.LBB56:
 101:source/HvMessage.h **** }
 508              		.loc 2 101 3 view .LVU129
 101:source/HvMessage.h **** }
 509              		.loc 2 101 3 is_stmt 0 view .LVU130
 510              	.LBE56:
 511              	.LBE57:
 512              		.loc 2 126 83 view .LVU131
 513 003a 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 514 003c 012B     		cmp	r3, #1
 515 003e EED1     		bne	.L28
 516              	.LVL44:
 517              		.loc 2 126 83 view .LVU132
 518              	.LBE59:
 519              	.LBE61:
 520              	.LBB62:
 521              	.LBB63:
 122:source/HvMessage.h **** }
 522              		.loc 2 122 3 is_stmt 1 view .LVU133
 122:source/HvMessage.h **** }
 523              		.loc 2 122 34 is_stmt 0 view .LVU134
 524 0040 D4ED057A 		vldr.32	s15, [r4, #20]
 525              	.LVL45:
 122:source/HvMessage.h **** }
 526              		.loc 2 122 34 view .LVU135
 527              	.LBE63:
 528              	.LBE62:
  98:source/HvTable.c ****     hTable_resize(o, (int) hv_ceil_f(msg_getFloat(m,1))); // apply ceil to ensure that tables alway
 529              		.loc 1 98 59 view .LVU136
 530 0044 F5EEC07A 		vcmpe.f32	s15, #0
 531 0048 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 532 004c E7DB     		blt	.L28
 533              	.LBB64:
  99:source/HvTable.c **** 
 534              		.loc 1 99 5 is_stmt 1 view .LVU137
 535              	.LVL46:
  99:source/HvTable.c **** 
 536              		.loc 1 99 5 is_stmt 0 view .LVU138
 537              	.LBE64:
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 538              		.loc 2 121 3 is_stmt 1 view .LVU139
  91:source/HvMessage.h **** }
 539              		.loc 2 91 3 view .LVU140
 122:source/HvMessage.h **** }
 540              		.loc 2 122 3 view .LVU141
 541              	.LBB69:
  99:source/HvTable.c **** 
 542              		.loc 1 99 28 is_stmt 0 view .LVU142
 543 004e FAFE677A 		vrintp.f32	s15, s15
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 16


  99:source/HvTable.c **** 
 544              		.loc 1 99 5 view .LVU143
 545 0052 FDEEE77A 		vcvt.s32.f32	s15, s15
 546 0056 2846     		mov	r0, r5
 547 0058 17EE901A 		vmov	r1, s15	@ int
 548 005c FFF7FEFF 		bl	hTable_resize
 549              	.LVL47:
 102:source/HvTable.c ****     msg_initWithFloat(n, msg_getTimestamp(m), (float) hTable_getSize(o));
 550              		.loc 1 102 5 is_stmt 1 view .LVU144
 102:source/HvTable.c ****     msg_initWithFloat(n, msg_getTimestamp(m), (float) hTable_getSize(o));
 551              		.loc 1 102 5 is_stmt 0 view .LVU145
 552              	.LBE69:
  58:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
 553              		.loc 2 58 3 is_stmt 1 view .LVU146
  59:source/HvMessage.h **** }
 554              		.loc 2 59 3 view .LVU147
 555              	.LBB70:
 102:source/HvTable.c ****     msg_initWithFloat(n, msg_getTimestamp(m), (float) hTable_getSize(o));
 556              		.loc 1 102 20 is_stmt 0 view .LVU148
 557 0060 84B0     		sub	sp, sp, #16
 103:source/HvTable.c ****     sendMessage(_c, 0, n);
 558              		.loc 1 103 5 view .LVU149
 559 0062 95ED020A 		vldr.32	s0, [r5, #8]	@ int
 102:source/HvTable.c ****     msg_initWithFloat(n, msg_getTimestamp(m), (float) hTable_getSize(o));
 560              		.loc 1 102 20 view .LVU150
 561 0066 6A46     		mov	r2, sp
 562              	.LVL48:
 103:source/HvTable.c ****     sendMessage(_c, 0, n);
 563              		.loc 1 103 5 is_stmt 1 view .LVU151
 564              	.LBB65:
 565              	.LBI65:
  82:source/HvMessage.h ****   return m->timestamp;
 566              		.loc 2 82 27 view .LVU152
 567              	.LBB66:
  83:source/HvMessage.h **** }
 568              		.loc 2 83 3 view .LVU153
  83:source/HvMessage.h **** }
 569              		.loc 2 83 3 is_stmt 0 view .LVU154
 570              	.LBE66:
 571              	.LBE65:
 572              	.LBB67:
 573              	.LBI67:
 574              		.file 3 "source/HvTable.h"
   1:source/HvTable.h **** /**
   2:source/HvTable.h ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvTable.h ****  *
   4:source/HvTable.h ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvTable.h ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvTable.h ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvTable.h ****  *
   8:source/HvTable.h ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvTable.h ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvTable.h ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvTable.h ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvTable.h ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvTable.h ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvTable.h ****  * PERFORMANCE OF THIS SOFTWARE.
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 17


  15:source/HvTable.h ****  */
  16:source/HvTable.h **** 
  17:source/HvTable.h **** #ifndef _HEAVY_TABLE_H_
  18:source/HvTable.h **** #define _HEAVY_TABLE_H_
  19:source/HvTable.h **** 
  20:source/HvTable.h **** #include "HvHeavy.h"
  21:source/HvTable.h **** #include "HvUtils.h"
  22:source/HvTable.h **** 
  23:source/HvTable.h **** #ifdef __cplusplus
  24:source/HvTable.h **** extern "C" {
  25:source/HvTable.h **** #endif
  26:source/HvTable.h **** 
  27:source/HvTable.h **** typedef struct HvTable {
  28:source/HvTable.h ****   float *buffer;
  29:source/HvTable.h ****   // the number of values that the table is requested to have
  30:source/HvTable.h ****   hv_uint32_t length;
  31:source/HvTable.h **** 
  32:source/HvTable.h ****   // the number of usable values that the table actually has
  33:source/HvTable.h ****   // this is always an even multiple of HV_N_SIMD
  34:source/HvTable.h ****   hv_uint32_t size;
  35:source/HvTable.h **** 
  36:source/HvTable.h ****   // Note that the true size of the table is (size + HV_N_SIMD),
  37:source/HvTable.h ****   // with the trailing values used by the system, e.g. to create a circular
  38:source/HvTable.h ****   // buffer
  39:source/HvTable.h ****   hv_uint32_t allocated;
  40:source/HvTable.h **** 
  41:source/HvTable.h ****   hv_uint32_t head; // the most recently written point
  42:source/HvTable.h **** } HvTable;
  43:source/HvTable.h **** 
  44:source/HvTable.h **** hv_size_t hTable_init(HvTable *o, int length);
  45:source/HvTable.h **** 
  46:source/HvTable.h **** hv_size_t hTable_initWithData(HvTable *o, int length, const float *data);
  47:source/HvTable.h **** 
  48:source/HvTable.h **** hv_size_t hTable_initWithFinalData(HvTable *o, int length, float *data);
  49:source/HvTable.h **** 
  50:source/HvTable.h **** void hTable_free(HvTable *o);
  51:source/HvTable.h **** 
  52:source/HvTable.h **** int hTable_resize(HvTable *o, hv_uint32_t newLength);
  53:source/HvTable.h **** 
  54:source/HvTable.h **** void hTable_onMessage(HeavyContextInterface *_c, HvTable *o, int letIn, const HvMessage *m,
  55:source/HvTable.h ****     void (*sendMessage)(HeavyContextInterface *, int, const HvMessage *));
  56:source/HvTable.h **** 
  57:source/HvTable.h **** static inline float *hTable_getBuffer(HvTable *o) {
  58:source/HvTable.h ****   return o->buffer;
  59:source/HvTable.h **** }
  60:source/HvTable.h **** 
  61:source/HvTable.h **** // the user-requested length of the table (number of floats)
  62:source/HvTable.h **** static inline hv_uint32_t hTable_getLength(HvTable *o) {
  63:source/HvTable.h ****   return o->length;
  64:source/HvTable.h **** }
  65:source/HvTable.h **** 
  66:source/HvTable.h **** // the usable length of the table (an even multiple of HV_N_SIMD)
  67:source/HvTable.h **** static inline hv_uint32_t hTable_getSize(HvTable *o) {
 575              		.loc 3 67 27 is_stmt 1 view .LVU155
 576              	.LBB68:
  68:source/HvTable.h ****   return o->size;
 577              		.loc 3 68 3 view .LVU156
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 18


 578              		.loc 3 68 3 is_stmt 0 view .LVU157
 579              	.LBE68:
 580              	.LBE67:
 103:source/HvTable.c ****     sendMessage(_c, 0, n);
 581              		.loc 1 103 5 view .LVU158
 582 0068 2168     		ldr	r1, [r4]
 583 006a B8EE400A 		vcvt.f32.u32	s0, s0
 584 006e 1046     		mov	r0, r2
 585 0070 7A60     		str	r2, [r7, #4]
 586 0072 FFF7FEFF 		bl	msg_initWithFloat
 587              	.LVL49:
 104:source/HvTable.c ****   }
 588              		.loc 1 104 5 is_stmt 1 view .LVU159
 589 0076 7A68     		ldr	r2, [r7, #4]
 590 0078 3B6A     		ldr	r3, [r7, #32]
 591 007a 0021     		movs	r1, #0
 592 007c 3046     		mov	r0, r6
 593 007e 9847     		blx	r3
 594              	.LVL50:
 595              	.LBE70:
 596              		.loc 1 110 1 is_stmt 0 view .LVU160
 597 0080 0C37     		adds	r7, r7, #12
 598              		.cfi_def_cfa_offset 20
 599 0082 BD46     		mov	sp, r7
 600              		.cfi_def_cfa_register 13
 601              	.LVL51:
 602              		.loc 1 110 1 view .LVU161
 603              		@ sp needed
 604 0084 F0BD     		pop	{r4, r5, r6, r7, pc}
 605              	.LVL52:
 606              	.L41:
 607              		.loc 1 110 1 view .LVU162
 608 0086 00BF     		.align	2
 609              	.L40:
 610 0088 00000000 		.word	.LC3
 611 008c 08000000 		.word	.LC4
 612              		.cfi_endproc
 613              	.LFE356:
 615              		.section	.rodata.__func__.3,"a"
 616              		.align	2
 617              		.set	.LANCHOR2,. + 0
 620              	__func__.3:
 621 0000 68546162 		.ascii	"hTable_resize\000"
 621      6C655F72 
 621      6573697A 
 621      6500
 622              		.section	.rodata.__func__.4,"a"
 623              		.align	2
 624              		.set	.LANCHOR1,. + 0
 627              	__func__.4:
 628 0000 68546162 		.ascii	"hTable_initWithData\000"
 628      6C655F69 
 628      6E697457 
 628      69746844 
 628      61746100 
 629              		.section	.rodata.__func__.5,"a"
 630              		.align	2
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 19


 631              		.set	.LANCHOR0,. + 0
 634              	__func__.5:
 635 0000 68546162 		.ascii	"hTable_init\000"
 635      6C655F69 
 635      6E697400 
 636              		.text
 637              	.Letext0:
 638              		.file 4 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/machine/_default_types.h"
 639              		.file 5 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/sys/_stdint.h"
 640              		.file 6 "/Library/DaisyToolchain/0.2.0/arm/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 641              		.file 7 "source/HvHeavy.h"
 642              		.file 8 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/stdlib.h"
 643              		.file 9 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/assert.h"
 644              		.file 10 "<built-in>"
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s 			page 20


DEFINED SYMBOLS
                            *ABS*:0000000000000000 HvTable.c
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:19     .rodata.hTable_init.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:26     .text.hTable_init:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:33     .text.hTable_init:0000000000000000 hTable_init
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:98     .text.hTable_init:0000000000000030 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:105    .text.hTable_initWithData:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:112    .text.hTable_initWithData:0000000000000000 hTable_initWithData
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:184    .text.hTable_initWithData:000000000000003c $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:191    .text.hTable_initWithFinalData:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:198    .text.hTable_initWithFinalData:0000000000000000 hTable_initWithFinalData
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:240    .text.hTable_free:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:247    .text.hTable_free:0000000000000000 hTable_free
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:265    .rodata.hTable_resize.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:269    .text.hTable_resize:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:276    .text.hTable_resize:0000000000000000 hTable_resize
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:380    .text.hTable_resize:0000000000000060 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:387    .rodata.hTable_onMessage.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:394    .text.hTable_onMessage:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:401    .text.hTable_onMessage:0000000000000000 hTable_onMessage
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:610    .text.hTable_onMessage:0000000000000088 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:616    .rodata.__func__.3:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:620    .rodata.__func__.3:0000000000000000 __func__.3
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:623    .rodata.__func__.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:627    .rodata.__func__.4:0000000000000000 __func__.4
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:630    .rodata.__func__.5:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccLrcwKs.s:634    .rodata.__func__.5:0000000000000000 __func__.5

UNDEFINED SYMBOLS
calloc
__assert_func
memcpy
free
realloc
memset
msg_compareSymbol
msg_initWithFloat
