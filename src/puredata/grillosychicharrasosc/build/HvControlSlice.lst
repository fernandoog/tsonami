ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 1


   1              		.cpu cortex-m7
   2              		.arch armv7e-m
   3              		.fpu fpv5-d16
   4              		.eabi_attribute 28, 1
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 2
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.file	"HvControlSlice.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata.msg_getFloat.part.0.str1.4,"aMS",%progbits,1
  19              		.align	2
  20              	.LC0:
  21 0000 696E6465 		.ascii	"index < msg_getNumElements(m)\000"
  21      78203C20 
  21      6D73675F 
  21      6765744E 
  21      756D456C 
  22 001e 0000     		.align	2
  23              	.LC1:
  24 0020 736F7572 		.ascii	"source/HvMessage.h\000"
  24      63652F48 
  24      764D6573 
  24      73616765 
  24      2E6800
  25              		.section	.text.msg_getFloat.part.0,"ax",%progbits
  26              		.align	1
  27              		.p2align 2,,3
  28              		.syntax unified
  29              		.thumb
  30              		.thumb_func
  32              	msg_getFloat.part.0:
  33              	.LFB402:
  34              		.file 1 "source/HvMessage.h"
   1:source/HvMessage.h **** /**
   2:source/HvMessage.h ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvMessage.h ****  *
   4:source/HvMessage.h ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvMessage.h ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvMessage.h ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvMessage.h ****  *
   8:source/HvMessage.h ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvMessage.h ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvMessage.h ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvMessage.h ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvMessage.h ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvMessage.h ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvMessage.h ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvMessage.h ****  */
  16:source/HvMessage.h **** 
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 2


  17:source/HvMessage.h **** #ifndef _HEAVY_MESSAGE_H_
  18:source/HvMessage.h **** #define _HEAVY_MESSAGE_H_
  19:source/HvMessage.h **** 
  20:source/HvMessage.h **** #include "HvUtils.h"
  21:source/HvMessage.h **** 
  22:source/HvMessage.h **** #ifdef __cplusplus
  23:source/HvMessage.h **** extern "C" {
  24:source/HvMessage.h **** #endif
  25:source/HvMessage.h **** 
  26:source/HvMessage.h **** typedef enum ElementType {
  27:source/HvMessage.h ****   HV_MSG_BANG = 0,
  28:source/HvMessage.h ****   HV_MSG_FLOAT = 1,
  29:source/HvMessage.h ****   HV_MSG_SYMBOL = 2,
  30:source/HvMessage.h ****   HV_MSG_HASH = 3
  31:source/HvMessage.h **** } ElementType;
  32:source/HvMessage.h **** 
  33:source/HvMessage.h **** typedef struct Element {
  34:source/HvMessage.h ****   ElementType type;
  35:source/HvMessage.h ****   union {
  36:source/HvMessage.h ****     float f; // float
  37:source/HvMessage.h ****     const char *s; // symbol
  38:source/HvMessage.h ****     hv_uint32_t h; // hash
  39:source/HvMessage.h ****   } data;
  40:source/HvMessage.h **** } Element;
  41:source/HvMessage.h **** 
  42:source/HvMessage.h **** typedef struct HvMessage {
  43:source/HvMessage.h ****   hv_uint32_t timestamp; // the sample at which this message should be processed
  44:source/HvMessage.h ****   hv_uint16_t numElements;
  45:source/HvMessage.h ****   hv_uint16_t numBytes; // the total number of bytes that this message occupies in memory, includin
  46:source/HvMessage.h ****   Element elem;
  47:source/HvMessage.h **** } HvMessage;
  48:source/HvMessage.h **** 
  49:source/HvMessage.h **** typedef struct ReceiverMessagePair {
  50:source/HvMessage.h ****   hv_uint32_t receiverHash;
  51:source/HvMessage.h ****   HvMessage msg;
  52:source/HvMessage.h **** } ReceiverMessagePair;
  53:source/HvMessage.h **** 
  54:source/HvMessage.h **** #define HV_MESSAGE_ON_STACK(_x) (HvMessage *) hv_alloca(msg_getCoreSize(_x))
  55:source/HvMessage.h **** 
  56:source/HvMessage.h **** /** Returns the number of bytes that this message consumes in memory, not including strings. */
  57:source/HvMessage.h **** static inline hv_size_t msg_getCoreSize(hv_size_t numElements) {
  58:source/HvMessage.h ****   hv_assert(numElements > 0);
  59:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
  60:source/HvMessage.h **** }
  61:source/HvMessage.h **** 
  62:source/HvMessage.h **** HvMessage *msg_copy(const HvMessage *m);
  63:source/HvMessage.h **** 
  64:source/HvMessage.h **** /** Copies the message into the given buffer. The buffer must be at least as large as msg_getNumHea
  65:source/HvMessage.h **** void msg_copyToBuffer(const HvMessage *m, char *buffer, hv_size_t len);
  66:source/HvMessage.h **** 
  67:source/HvMessage.h **** void msg_setElementToFrom(HvMessage *n, int indexN, const HvMessage *const m, int indexM);
  68:source/HvMessage.h **** 
  69:source/HvMessage.h **** /** Frees a message on the heap. Does nothing if argument is NULL. */
  70:source/HvMessage.h **** void msg_free(HvMessage *m);
  71:source/HvMessage.h **** 
  72:source/HvMessage.h **** HvMessage *msg_init(HvMessage *m, hv_size_t numElements, hv_uint32_t timestamp);
  73:source/HvMessage.h **** 
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 3


  74:source/HvMessage.h **** HvMessage *msg_initWithFloat(HvMessage *m, hv_uint32_t timestamp, float f);
  75:source/HvMessage.h **** 
  76:source/HvMessage.h **** HvMessage *msg_initWithBang(HvMessage *m, hv_uint32_t timestamp);
  77:source/HvMessage.h **** 
  78:source/HvMessage.h **** HvMessage *msg_initWithSymbol(HvMessage *m, hv_uint32_t timestamp, const char *s);
  79:source/HvMessage.h **** 
  80:source/HvMessage.h **** HvMessage *msg_initWithHash(HvMessage *m, hv_uint32_t timestamp, hv_uint32_t h);
  81:source/HvMessage.h **** 
  82:source/HvMessage.h **** static inline hv_uint32_t msg_getTimestamp(const HvMessage *m) {
  83:source/HvMessage.h ****   return m->timestamp;
  84:source/HvMessage.h **** }
  85:source/HvMessage.h **** 
  86:source/HvMessage.h **** static inline void msg_setTimestamp(HvMessage *m, hv_uint32_t timestamp) {
  87:source/HvMessage.h ****   m->timestamp = timestamp;
  88:source/HvMessage.h **** }
  89:source/HvMessage.h **** 
  90:source/HvMessage.h **** static inline int msg_getNumElements(const HvMessage *m) {
  91:source/HvMessage.h ****   return (int) m->numElements;
  92:source/HvMessage.h **** }
  93:source/HvMessage.h **** 
  94:source/HvMessage.h **** /** Returns the total number of bytes this message consumes in memory. */
  95:source/HvMessage.h **** static inline hv_uint32_t msg_getSize(const HvMessage *m) {
  96:source/HvMessage.h ****   return m->numBytes;
  97:source/HvMessage.h **** }
  98:source/HvMessage.h **** 
  99:source/HvMessage.h **** static inline ElementType msg_getType(const HvMessage *m, int index) {
 100:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 101:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 102:source/HvMessage.h **** }
 103:source/HvMessage.h **** 
 104:source/HvMessage.h **** static inline void msg_setBang(HvMessage *m, int index) {
 105:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 106:source/HvMessage.h ****   (&(m->elem)+index)->type = HV_MSG_BANG;
 107:source/HvMessage.h ****   (&(m->elem)+index)->data.s = NULL;
 108:source/HvMessage.h **** }
 109:source/HvMessage.h **** 
 110:source/HvMessage.h **** static inline bool msg_isBang(const HvMessage *m, int index) {
 111:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_BANG) : false;
 112:source/HvMessage.h **** }
 113:source/HvMessage.h **** 
 114:source/HvMessage.h **** static inline void msg_setFloat(HvMessage *m, int index, float f) {
 115:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 116:source/HvMessage.h ****   (&(m->elem)+index)->type = HV_MSG_FLOAT;
 117:source/HvMessage.h ****   (&(m->elem)+index)->data.f = f;
 118:source/HvMessage.h **** }
 119:source/HvMessage.h **** 
 120:source/HvMessage.h **** static inline float msg_getFloat(const HvMessage *const m, int index) {
  35              		.loc 1 120 21 view -0
  36              		.cfi_startproc
  37              		@ Volatile: function does not return.
  38              		@ args = 0, pretend = 0, frame = 0
  39              		@ frame_needed = 0, uses_anonymous_args = 0
  40              	.LVL0:
  41              		.loc 1 120 21 is_stmt 0 view .LVU1
  42 0000 08B5     		push	{r3, lr}
  43              		.cfi_def_cfa_offset 8
  44              		.cfi_offset 3, -8
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 4


  45              		.cfi_offset 14, -4
 121:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
  46              		.loc 1 121 3 view .LVU2
  47 0002 034A     		ldr	r2, .L4
  48 0004 7921     		movs	r1, #121
  49 0006 034B     		ldr	r3, .L4+4
  50 0008 0348     		ldr	r0, .L4+8
  51 000a FFF7FEFF 		bl	__assert_func
  52              	.LVL1:
  53              	.L5:
  54 000e 00BF     		.align	2
  55              	.L4:
  56 0010 00000000 		.word	.LANCHOR0
  57 0014 00000000 		.word	.LC0
  58 0018 20000000 		.word	.LC1
  59              		.cfi_endproc
  60              	.LFE402:
  62              		.section	.text.cSlice_init,"ax",%progbits
  63              		.align	1
  64              		.p2align 2,,3
  65              		.global	cSlice_init
  66              		.syntax unified
  67              		.thumb
  68              		.thumb_func
  70              	cSlice_init:
  71              	.LVL2:
  72              	.LFB399:
  73              		.file 2 "source/HvControlSlice.c"
   1:source/HvControlSlice.c **** /**
   2:source/HvControlSlice.c ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvControlSlice.c ****  *
   4:source/HvControlSlice.c ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvControlSlice.c ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvControlSlice.c ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvControlSlice.c ****  *
   8:source/HvControlSlice.c ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvControlSlice.c ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvControlSlice.c ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvControlSlice.c ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvControlSlice.c ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvControlSlice.c ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvControlSlice.c ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvControlSlice.c ****  */
  16:source/HvControlSlice.c **** 
  17:source/HvControlSlice.c **** #include "HvControlSlice.h"
  18:source/HvControlSlice.c **** 
  19:source/HvControlSlice.c **** hv_size_t cSlice_init(ControlSlice *o, int i, int n) {
  74              		.loc 2 19 54 is_stmt 1 view -0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 0, uses_anonymous_args = 0
  78              		@ link register save eliminated.
  20:source/HvControlSlice.c ****   o->i = i;
  79              		.loc 2 20 3 view .LVU4
  19:source/HvControlSlice.c ****   o->i = i;
  80              		.loc 2 19 54 is_stmt 0 view .LVU5
  81 0000 0346     		mov	r3, r0
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 5


  21:source/HvControlSlice.c ****   o->n = n;
  22:source/HvControlSlice.c ****   return 0;
  23:source/HvControlSlice.c **** }
  82              		.loc 2 23 1 view .LVU6
  83 0002 0020     		movs	r0, #0
  84              	.LVL3:
  21:source/HvControlSlice.c ****   o->n = n;
  85              		.loc 2 21 8 view .LVU7
  86 0004 C3E90012 		strd	r1, r2, [r3]
  22:source/HvControlSlice.c **** }
  87              		.loc 2 22 3 is_stmt 1 view .LVU8
  88              		.loc 2 23 1 is_stmt 0 view .LVU9
  89 0008 7047     		bx	lr
  90              		.cfi_endproc
  91              	.LFE399:
  93 000a 00BF     		.section	.rodata.cSlice_onMessage.str1.4,"aMS",%progbits,1
  94              		.align	2
  95              	.LC2:
  96 0000 6E756D45 		.ascii	"numElements > 0\000"
  96      6C656D65 
  96      6E747320 
  96      3E203000 
  97              		.section	.text.cSlice_onMessage,"ax",%progbits
  98              		.align	1
  99              		.p2align 2,,3
 100              		.global	cSlice_onMessage
 101              		.syntax unified
 102              		.thumb
 103              		.thumb_func
 105              	cSlice_onMessage:
 106              	.LVL4:
 107              	.LFB400:
  24:source/HvControlSlice.c **** 
  25:source/HvControlSlice.c **** void cSlice_onMessage(HeavyContextInterface *_c, ControlSlice *o, int letIn, const HvMessage *m,
  26:source/HvControlSlice.c ****     void (*sendMessage)(HeavyContextInterface *, int, const HvMessage *)) {
 108              		.loc 2 26 75 is_stmt 1 view -0
 109              		.cfi_startproc
 110              		@ args = 4, pretend = 0, frame = 8
 111              		@ frame_needed = 1, uses_anonymous_args = 0
  27:source/HvControlSlice.c ****   switch (letIn) {
 112              		.loc 2 27 3 view .LVU11
  26:source/HvControlSlice.c ****   switch (letIn) {
 113              		.loc 2 26 75 is_stmt 0 view .LVU12
 114 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 115              		.cfi_def_cfa_offset 28
 116              		.cfi_offset 4, -28
 117              		.cfi_offset 5, -24
 118              		.cfi_offset 6, -20
 119              		.cfi_offset 7, -16
 120              		.cfi_offset 8, -12
 121              		.cfi_offset 9, -8
 122              		.cfi_offset 14, -4
 123              		.loc 2 27 3 view .LVU13
 124 0004 012A     		cmp	r2, #1
  26:source/HvControlSlice.c ****   switch (letIn) {
 125              		.loc 2 26 75 view .LVU14
 126 0006 83B0     		sub	sp, sp, #12
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 6


 127              		.cfi_def_cfa_offset 40
 128 0008 0C46     		mov	r4, r1
 129 000a 00AF     		add	r7, sp, #0
 130              		.cfi_def_cfa_register 7
 131              		.loc 2 27 3 view .LVU15
 132 000c 06D0     		beq	.L8
 133 000e 022A     		cmp	r2, #2
 134 0010 49D0     		beq	.L9
 135 0012 DAB1     		cbz	r2, .L23
 136              	.LVL5:
 137              	.L7:
  28:source/HvControlSlice.c ****     case 0: {
  29:source/HvControlSlice.c ****       // if the start point is greater than the number of elements in the source message, do nothin
  30:source/HvControlSlice.c ****       if (o->i < msg_getNumElements(m)) {
  31:source/HvControlSlice.c ****         int x = msg_getNumElements(m) - o->i; // number of elements in the new message
  32:source/HvControlSlice.c ****         if (o->n > 0) x = hv_min_i(x, o->n);
  33:source/HvControlSlice.c ****         HvMessage *n = HV_MESSAGE_ON_STACK(x);
  34:source/HvControlSlice.c ****         msg_init(n, x, msg_getTimestamp(m));
  35:source/HvControlSlice.c ****         hv_memcpy(&n->elem, &m->elem+o->i, x*sizeof(Element));
  36:source/HvControlSlice.c ****         sendMessage(_c, 0, n);
  37:source/HvControlSlice.c ****       } else {
  38:source/HvControlSlice.c ****         // if nothing can be sliced, send a bang out of the right outlet
  39:source/HvControlSlice.c ****         HvMessage *n = HV_MESSAGE_ON_STACK(1);
  40:source/HvControlSlice.c ****         msg_initWithBang(n, msg_getTimestamp(m));
  41:source/HvControlSlice.c ****         sendMessage(_c, 1, n);
  42:source/HvControlSlice.c ****       }
  43:source/HvControlSlice.c ****       break;
  44:source/HvControlSlice.c ****     }
  45:source/HvControlSlice.c ****     case 1: {
  46:source/HvControlSlice.c ****       if (msg_isFloat(m,0)) {
  47:source/HvControlSlice.c ****         o->i = (int) msg_getFloat(m,0);
  48:source/HvControlSlice.c ****         if (msg_isFloat(m,1)) {
  49:source/HvControlSlice.c ****           o->n = (int) msg_getFloat(m,1);
  50:source/HvControlSlice.c ****         }
  51:source/HvControlSlice.c ****       }
  52:source/HvControlSlice.c ****       break;
  53:source/HvControlSlice.c ****     }
  54:source/HvControlSlice.c ****     case 2: {
  55:source/HvControlSlice.c ****       if (msg_isFloat(m,0)) {
  56:source/HvControlSlice.c ****         o->n = (int) msg_getFloat(m,0);
  57:source/HvControlSlice.c ****       }
  58:source/HvControlSlice.c ****       break;
  59:source/HvControlSlice.c ****     }
  60:source/HvControlSlice.c ****     default: break;
  61:source/HvControlSlice.c ****   }
  62:source/HvControlSlice.c **** }
 138              		.loc 2 62 1 view .LVU16
 139 0014 0C37     		adds	r7, r7, #12
 140              		.cfi_remember_state
 141              		.cfi_def_cfa_offset 28
 142 0016 BD46     		mov	sp, r7
 143              		.cfi_def_cfa_register 13
 144              		@ sp needed
 145 0018 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 146              	.LVL6:
 147              	.L8:
 148              		.cfi_restore_state
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 7


  46:source/HvControlSlice.c ****         o->i = (int) msg_getFloat(m,0);
 149              		.loc 2 46 7 is_stmt 1 view .LVU17
 150              	.LBB86:
 151              	.LBI86:
 122:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 123:source/HvMessage.h **** }
 124:source/HvMessage.h **** 
 125:source/HvMessage.h **** static inline bool msg_isFloat(const HvMessage *const m, int index) {
 152              		.loc 1 125 20 view .LVU18
 153              	.LBB87:
 126:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_FLOAT) : false;
 154              		.loc 1 126 3 view .LVU19
 155              	.LBB88:
 156              	.LBI88:
  90:source/HvMessage.h ****   return (int) m->numElements;
 157              		.loc 1 90 19 view .LVU20
 158              	.LBB89:
  91:source/HvMessage.h **** }
 159              		.loc 1 91 3 view .LVU21
  91:source/HvMessage.h **** }
 160              		.loc 1 91 17 is_stmt 0 view .LVU22
 161 001c 9A88     		ldrh	r2, [r3, #4]
 162              	.LVL7:
  91:source/HvMessage.h **** }
 163              		.loc 1 91 17 view .LVU23
 164              	.LBE89:
 165              	.LBE88:
 166              		.loc 1 126 83 view .LVU24
 167 001e 002A     		cmp	r2, #0
 168 0020 F8D0     		beq	.L7
 169              	.LVL8:
 170              	.LBB90:
 171              	.LBI90:
  99:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 172              		.loc 1 99 27 is_stmt 1 view .LVU25
 173              	.LBB91:
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 174              		.loc 1 100 3 view .LVU26
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 175              		.loc 1 100 3 is_stmt 0 view .LVU27
 176              	.LBE91:
 177              	.LBE90:
 178              	.LBE87:
 179              	.LBE86:
  91:source/HvMessage.h **** }
 180              		.loc 1 91 3 is_stmt 1 view .LVU28
 181              	.LBB95:
 182              	.LBB94:
 183              	.LBB93:
 184              	.LBB92:
 101:source/HvMessage.h **** }
 185              		.loc 1 101 3 view .LVU29
 101:source/HvMessage.h **** }
 186              		.loc 1 101 3 is_stmt 0 view .LVU30
 187              	.LBE92:
 188              	.LBE93:
 189              		.loc 1 126 83 view .LVU31
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 8


 190 0022 197A     		ldrb	r1, [r3, #8]	@ zero_extendqisi2
 191              	.LVL9:
 192              		.loc 1 126 83 view .LVU32
 193 0024 0129     		cmp	r1, #1
 194 0026 F5D1     		bne	.L7
 195              	.LVL10:
 196              		.loc 1 126 83 view .LVU33
 197              	.LBE94:
 198              	.LBE95:
  47:source/HvControlSlice.c ****         if (msg_isFloat(m,1)) {
 199              		.loc 2 47 9 is_stmt 1 view .LVU34
 200              	.LBB96:
 201              	.LBI96:
 120:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 202              		.loc 1 120 21 view .LVU35
 203              	.LBB97:
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 204              		.loc 1 121 3 view .LVU36
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 205              		.loc 1 121 3 is_stmt 0 view .LVU37
 206              	.LBE97:
 207              	.LBE96:
  91:source/HvMessage.h **** }
 208              		.loc 1 91 3 is_stmt 1 view .LVU38
 209              	.LBB99:
 210              	.LBB98:
 122:source/HvMessage.h **** }
 211              		.loc 1 122 3 view .LVU39
 122:source/HvMessage.h **** }
 212              		.loc 1 122 3 is_stmt 0 view .LVU40
 213              	.LBE98:
 214              	.LBE99:
  47:source/HvControlSlice.c ****         if (msg_isFloat(m,1)) {
 215              		.loc 2 47 16 view .LVU41
 216 0028 D3ED037A 		vldr.32	s15, [r3, #12]
 217              	.LBB100:
 218              	.LBB101:
 219              		.loc 1 126 83 view .LVU42
 220 002c 012A     		cmp	r2, #1
 221              	.LBE101:
 222              	.LBE100:
  47:source/HvControlSlice.c ****         if (msg_isFloat(m,1)) {
 223              		.loc 2 47 16 view .LVU43
 224 002e FDEEE77A 		vcvt.s32.f32	s15, s15
 225 0032 C4ED007A 		vstr.32	s15, [r4]	@ int
  48:source/HvControlSlice.c ****           o->n = (int) msg_getFloat(m,1);
 226              		.loc 2 48 9 is_stmt 1 view .LVU44
 227              	.LVL11:
 228              	.LBB109:
 229              	.LBI100:
 125:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_FLOAT) : false;
 230              		.loc 1 125 20 view .LVU45
 231              	.LBB106:
 232              		.loc 1 126 3 view .LVU46
 233              		.loc 1 126 3 is_stmt 0 view .LVU47
 234              	.LBE106:
 235              	.LBE109:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 9


  91:source/HvMessage.h **** }
 236              		.loc 1 91 3 is_stmt 1 view .LVU48
 237              	.LBB110:
 238              	.LBB107:
 239              		.loc 1 126 83 is_stmt 0 view .LVU49
 240 0036 EDD0     		beq	.L7
 241              	.LVL12:
 242              	.LBB102:
 243              	.LBI102:
  99:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 244              		.loc 1 99 27 is_stmt 1 view .LVU50
 245              	.LBB103:
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 246              		.loc 1 100 3 view .LVU51
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 247              		.loc 1 100 3 is_stmt 0 view .LVU52
 248              	.LBE103:
 249              	.LBE102:
 250              	.LBE107:
 251              	.LBE110:
  91:source/HvMessage.h **** }
 252              		.loc 1 91 3 is_stmt 1 view .LVU53
 253              	.LBB111:
 254              	.LBB108:
 255              	.LBB105:
 256              	.LBB104:
 101:source/HvMessage.h **** }
 257              		.loc 1 101 3 view .LVU54
 101:source/HvMessage.h **** }
 258              		.loc 1 101 3 is_stmt 0 view .LVU55
 259              	.LBE104:
 260              	.LBE105:
 261              		.loc 1 126 83 view .LVU56
 262 0038 1A7C     		ldrb	r2, [r3, #16]	@ zero_extendqisi2
 263 003a 012A     		cmp	r2, #1
 264 003c EAD1     		bne	.L7
 265              	.LVL13:
 266              		.loc 1 126 83 view .LVU57
 267              	.LBE108:
 268              	.LBE111:
  49:source/HvControlSlice.c ****         }
 269              		.loc 2 49 11 is_stmt 1 view .LVU58
 270              	.LBB112:
 271              	.LBI112:
 120:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 272              		.loc 1 120 21 view .LVU59
 273              	.LBB113:
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 274              		.loc 1 121 3 view .LVU60
 121:source/HvMessage.h ****   return (&(m->elem)+index)->data.f;
 275              		.loc 1 121 3 is_stmt 0 view .LVU61
 276              	.LBE113:
 277              	.LBE112:
  91:source/HvMessage.h **** }
 278              		.loc 1 91 3 is_stmt 1 view .LVU62
 279              	.LBB115:
 280              	.LBB114:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 10


 122:source/HvMessage.h **** }
 281              		.loc 1 122 3 view .LVU63
 122:source/HvMessage.h **** }
 282              		.loc 1 122 3 is_stmt 0 view .LVU64
 283              	.LBE114:
 284              	.LBE115:
  49:source/HvControlSlice.c ****         }
 285              		.loc 2 49 18 view .LVU65
 286 003e D3ED057A 		vldr.32	s15, [r3, #20]
 287 0042 FDEEE77A 		vcvt.s32.f32	s15, s15
 288 0046 C4ED017A 		vstr.32	s15, [r4, #4]	@ int
 289 004a E3E7     		b	.L7
 290              	.LVL14:
 291              	.L23:
  30:source/HvControlSlice.c ****         int x = msg_getNumElements(m) - o->i; // number of elements in the new message
 292              		.loc 2 30 12 view .LVU66
 293 004c 0A68     		ldr	r2, [r1]
 294              	.LVL15:
  30:source/HvControlSlice.c ****         int x = msg_getNumElements(m) - o->i; // number of elements in the new message
 295              		.loc 2 30 12 view .LVU67
 296 004e 0546     		mov	r5, r0
  30:source/HvControlSlice.c ****         int x = msg_getNumElements(m) - o->i; // number of elements in the new message
 297              		.loc 2 30 7 is_stmt 1 view .LVU68
 298              	.LVL16:
 299              	.LBB116:
 300              	.LBI116:
  90:source/HvMessage.h ****   return (int) m->numElements;
 301              		.loc 1 90 19 view .LVU69
 302              	.LBB117:
  91:source/HvMessage.h **** }
 303              		.loc 1 91 3 view .LVU70
  91:source/HvMessage.h **** }
 304              		.loc 1 91 10 is_stmt 0 view .LVU71
 305 0050 9988     		ldrh	r1, [r3, #4]
 306              	.LVL17:
  91:source/HvMessage.h **** }
 307              		.loc 1 91 10 view .LVU72
 308              	.LBE117:
 309              	.LBE116:
  30:source/HvControlSlice.c ****         int x = msg_getNumElements(m) - o->i; // number of elements in the new message
 310              		.loc 2 30 10 view .LVU73
 311 0052 8A42     		cmp	r2, r1
 312 0054 37DA     		bge	.L11
 313              	.LBB118:
  31:source/HvControlSlice.c ****         if (o->n > 0) x = hv_min_i(x, o->n);
 314              		.loc 2 31 9 is_stmt 1 view .LVU74
 315              	.LVL18:
  31:source/HvControlSlice.c ****         if (o->n > 0) x = hv_min_i(x, o->n);
 316              		.loc 2 31 9 is_stmt 0 view .LVU75
 317              	.LBE118:
  91:source/HvMessage.h **** }
 318              		.loc 1 91 3 is_stmt 1 view .LVU76
 319              	.LBB131:
  32:source/HvControlSlice.c ****         HvMessage *n = HV_MESSAGE_ON_STACK(x);
 320              		.loc 2 32 14 is_stmt 0 view .LVU77
 321 0056 6068     		ldr	r0, [r4, #4]
 322              	.LVL19:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 11


  31:source/HvControlSlice.c ****         if (o->n > 0) x = hv_min_i(x, o->n);
 323              		.loc 2 31 13 view .LVU78
 324 0058 891A     		subs	r1, r1, r2
 325              	.LVL20:
  32:source/HvControlSlice.c ****         HvMessage *n = HV_MESSAGE_ON_STACK(x);
 326              		.loc 2 32 9 is_stmt 1 view .LVU79
  32:source/HvControlSlice.c ****         HvMessage *n = HV_MESSAGE_ON_STACK(x);
 327              		.loc 2 32 12 is_stmt 0 view .LVU80
 328 005a 0028     		cmp	r0, #0
 329 005c 02DD     		ble	.L12
  32:source/HvControlSlice.c ****         HvMessage *n = HV_MESSAGE_ON_STACK(x);
 330              		.loc 2 32 23 is_stmt 1 discriminator 1 view .LVU81
 331              	.LVL21:
 332              	.LBB119:
 333              	.LBI119:
 334              		.file 3 "source/HvUtils.h"
   1:source/HvUtils.h **** /**
   2:source/HvUtils.h ****  * Copyright (c) 2014-2018 Enzien Audio Ltd.
   3:source/HvUtils.h ****  *
   4:source/HvUtils.h ****  * Permission to use, copy, modify, and/or distribute this software for any
   5:source/HvUtils.h ****  * purpose with or without fee is hereby granted, provided that the above
   6:source/HvUtils.h ****  * copyright notice and this permission notice appear in all copies.
   7:source/HvUtils.h ****  *
   8:source/HvUtils.h ****  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   9:source/HvUtils.h ****  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  10:source/HvUtils.h ****  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  11:source/HvUtils.h ****  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  12:source/HvUtils.h ****  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  13:source/HvUtils.h ****  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  14:source/HvUtils.h ****  * PERFORMANCE OF THIS SOFTWARE.
  15:source/HvUtils.h ****  */
  16:source/HvUtils.h **** 
  17:source/HvUtils.h **** #ifndef _HEAVY_UTILS_H_
  18:source/HvUtils.h **** #define _HEAVY_UTILS_H_
  19:source/HvUtils.h **** 
  20:source/HvUtils.h **** // platform definitions
  21:source/HvUtils.h **** #if _WIN32 || _WIN64
  22:source/HvUtils.h ****   #define HV_WIN 1
  23:source/HvUtils.h **** #ifdef _MSC_VER
  24:source/HvUtils.h ****   #define HV_MSVC 1
  25:source/HvUtils.h **** #endif
  26:source/HvUtils.h **** #elif __APPLE__
  27:source/HvUtils.h ****   #define HV_APPLE 1
  28:source/HvUtils.h **** #elif __ANDROID__
  29:source/HvUtils.h ****   #define HV_ANDROID 1
  30:source/HvUtils.h **** #elif __unix__ || __unix
  31:source/HvUtils.h ****   #define HV_UNIX 1
  32:source/HvUtils.h **** #else
  33:source/HvUtils.h ****   #warning Could not detect platform. Assuming Unix-like.
  34:source/HvUtils.h **** #endif
  35:source/HvUtils.h **** 
  36:source/HvUtils.h **** #ifdef EMSCRIPTEN
  37:source/HvUtils.h **** #define HV_EMSCRIPTEN 1
  38:source/HvUtils.h **** #endif
  39:source/HvUtils.h **** 
  40:source/HvUtils.h **** // basic includes
  41:source/HvUtils.h **** #include <stdarg.h>
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 12


  42:source/HvUtils.h **** #include <stdio.h>
  43:source/HvUtils.h **** #include <stdlib.h>
  44:source/HvUtils.h **** 
  45:source/HvUtils.h **** // type definitions
  46:source/HvUtils.h **** #include <stdint.h>
  47:source/HvUtils.h **** #include <stdbool.h>
  48:source/HvUtils.h **** #define hv_uint8_t uint8_t
  49:source/HvUtils.h **** #define hv_int16_t int16_t
  50:source/HvUtils.h **** #define hv_uint16_t uint16_t
  51:source/HvUtils.h **** #define hv_int32_t int32_t
  52:source/HvUtils.h **** #define hv_uint32_t uint32_t
  53:source/HvUtils.h **** #define hv_uint64_t uint64_t
  54:source/HvUtils.h **** #define hv_size_t size_t
  55:source/HvUtils.h **** #define hv_uintptr_t uintptr_t
  56:source/HvUtils.h **** 
  57:source/HvUtils.h **** // SIMD-specific includes
  58:source/HvUtils.h **** #if !(HV_SIMD_NONE || HV_SIMD_NEON || HV_SIMD_SSE || HV_SIMD_AVX)
  59:source/HvUtils.h ****   #define HV_SIMD_NEON __ARM_NEON__
  60:source/HvUtils.h ****   #define HV_SIMD_SSE (__SSE__ && __SSE2__ && __SSE3__ && __SSSE3__ && __SSE4_1__)
  61:source/HvUtils.h ****   #define HV_SIMD_AVX (__AVX__ && HV_SIMD_SSE)
  62:source/HvUtils.h **** #endif
  63:source/HvUtils.h **** #ifndef HV_SIMD_FMA
  64:source/HvUtils.h ****   #define HV_SIMD_FMA __FMA__
  65:source/HvUtils.h **** #endif
  66:source/HvUtils.h **** 
  67:source/HvUtils.h **** #if HV_SIMD_AVX || HV_SIMD_SSE
  68:source/HvUtils.h ****   #include <immintrin.h>
  69:source/HvUtils.h **** #elif HV_SIMD_NEON
  70:source/HvUtils.h ****   #include <arm_neon.h>
  71:source/HvUtils.h **** #endif
  72:source/HvUtils.h **** 
  73:source/HvUtils.h **** #if HV_SIMD_NEON // NEON
  74:source/HvUtils.h ****   #define HV_N_SIMD 4
  75:source/HvUtils.h ****   #define hv_bufferf_t float32x4_t
  76:source/HvUtils.h ****   #define hv_bufferi_t int32x4_t
  77:source/HvUtils.h ****   #define hv_bInf_t float32x4_t
  78:source/HvUtils.h ****   #define hv_bOutf_t float32x4_t*
  79:source/HvUtils.h ****   #define hv_bIni_t int32x4_t
  80:source/HvUtils.h ****   #define hv_bOuti_t int32x4_t*
  81:source/HvUtils.h ****   #define VIf(_x) (_x)
  82:source/HvUtils.h ****   #define VOf(_x) (&_x)
  83:source/HvUtils.h ****   #define VIi(_x) (_x)
  84:source/HvUtils.h ****   #define VOi(_x) (&_x)
  85:source/HvUtils.h **** #elif HV_SIMD_AVX // AVX
  86:source/HvUtils.h ****   #define HV_N_SIMD 8
  87:source/HvUtils.h ****   #define hv_bufferf_t __m256
  88:source/HvUtils.h ****   #define hv_bufferi_t __m256i
  89:source/HvUtils.h ****   #define hv_bInf_t __m256
  90:source/HvUtils.h ****   #define hv_bOutf_t __m256*
  91:source/HvUtils.h ****   #define hv_bIni_t __m256i
  92:source/HvUtils.h ****   #define hv_bOuti_t __m256i*
  93:source/HvUtils.h ****   #define VIf(_x) (_x)
  94:source/HvUtils.h ****   #define VOf(_x) (&_x)
  95:source/HvUtils.h ****   #define VIi(_x) (_x)
  96:source/HvUtils.h ****   #define VOi(_x) (&_x)
  97:source/HvUtils.h **** #elif HV_SIMD_SSE // SSE
  98:source/HvUtils.h ****   #define HV_N_SIMD 4
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 13


  99:source/HvUtils.h ****   #define hv_bufferf_t __m128
 100:source/HvUtils.h ****   #define hv_bufferi_t __m128i
 101:source/HvUtils.h ****   #define hv_bInf_t __m128
 102:source/HvUtils.h ****   #define hv_bOutf_t __m128*
 103:source/HvUtils.h ****   #define hv_bIni_t __m128i
 104:source/HvUtils.h ****   #define hv_bOuti_t __m128i*
 105:source/HvUtils.h ****   #define VIf(_x) (_x)
 106:source/HvUtils.h ****   #define VOf(_x) (&_x)
 107:source/HvUtils.h ****   #define VIi(_x) (_x)
 108:source/HvUtils.h ****   #define VOi(_x) (&_x)
 109:source/HvUtils.h **** #else // DEFAULT
 110:source/HvUtils.h ****   #define HV_N_SIMD 1
 111:source/HvUtils.h ****   #undef HV_SIMD_NONE
 112:source/HvUtils.h ****   #define HV_SIMD_NONE 1
 113:source/HvUtils.h ****   #define hv_bufferf_t float
 114:source/HvUtils.h ****   #define hv_bufferi_t int
 115:source/HvUtils.h ****   #define hv_bInf_t float
 116:source/HvUtils.h ****   #define hv_bOutf_t float*
 117:source/HvUtils.h ****   #define hv_bIni_t int
 118:source/HvUtils.h ****   #define hv_bOuti_t int*
 119:source/HvUtils.h ****   #define VIf(_x) (_x)
 120:source/HvUtils.h ****   #define VOf(_x) (&_x)
 121:source/HvUtils.h ****   #define VIi(_x) (_x)
 122:source/HvUtils.h ****   #define VOi(_x) (&_x)
 123:source/HvUtils.h **** #endif
 124:source/HvUtils.h **** 
 125:source/HvUtils.h **** #define HV_N_SIMD_MASK (HV_N_SIMD-1)
 126:source/HvUtils.h **** 
 127:source/HvUtils.h **** // Strings
 128:source/HvUtils.h **** #include <string.h>
 129:source/HvUtils.h **** #define hv_strlen(a) strlen(a)
 130:source/HvUtils.h **** #define hv_strcmp(a, b) strcmp(a, b)
 131:source/HvUtils.h **** #define hv_snprintf(a, b, c, ...) snprintf(a, b, c, __VA_ARGS__)
 132:source/HvUtils.h **** #if HV_WIN
 133:source/HvUtils.h **** #define hv_strncpy(_dst, _src, _len) strncpy_s(_dst, _len, _src, _TRUNCATE)
 134:source/HvUtils.h **** #else
 135:source/HvUtils.h **** #define hv_strncpy(_dst, _src, _len) strncpy(_dst, _src, _len)
 136:source/HvUtils.h **** #endif
 137:source/HvUtils.h **** 
 138:source/HvUtils.h **** // Memory management
 139:source/HvUtils.h **** #define hv_memcpy(a, b, c) memcpy(a, b, c)
 140:source/HvUtils.h **** #define hv_memclear(a, b) memset(a, 0, b)
 141:source/HvUtils.h **** #if HV_MSVC
 142:source/HvUtils.h ****   #include <malloc.h>
 143:source/HvUtils.h ****   #define hv_alloca(_n) _alloca(_n)
 144:source/HvUtils.h ****   #if HV_SIMD_AVX
 145:source/HvUtils.h ****     #define hv_malloc(_n) _aligned_malloc(_n, 32)
 146:source/HvUtils.h ****     #define hv_realloc(a, b) _aligned_realloc(a, b, 32)
 147:source/HvUtils.h ****     #define hv_free(x) _aligned_free(x)
 148:source/HvUtils.h ****   #elif HV_SIMD_SSE || HV_SIMD_NEON
 149:source/HvUtils.h ****     #define hv_malloc(_n) _aligned_malloc(_n, 16)
 150:source/HvUtils.h ****     #define hv_realloc(a, b) _aligned_realloc(a, b, 16)
 151:source/HvUtils.h ****     #define hv_free(x) _aligned_free(x)
 152:source/HvUtils.h ****   #else // HV_SIMD_NONE
 153:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 154:source/HvUtils.h ****     #define hv_realloc(a, b) realloc(a, b)
 155:source/HvUtils.h ****     #define hv_free(_n) free(_n)
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 14


 156:source/HvUtils.h ****   #endif
 157:source/HvUtils.h **** #elif HV_APPLE
 158:source/HvUtils.h ****   #define hv_alloca(_n) alloca(_n)
 159:source/HvUtils.h ****   #define hv_realloc(a, b) realloc(a, b)
 160:source/HvUtils.h ****   #if HV_SIMD_AVX
 161:source/HvUtils.h ****     #include <mm_malloc.h>
 162:source/HvUtils.h ****     #define hv_malloc(_n) _mm_malloc(_n, 32)
 163:source/HvUtils.h ****     #define hv_free(x) _mm_free(x)
 164:source/HvUtils.h ****   #elif HV_SIMD_SSE
 165:source/HvUtils.h ****     #include <mm_malloc.h>
 166:source/HvUtils.h ****     #define hv_malloc(_n) _mm_malloc(_n, 16)
 167:source/HvUtils.h ****     #define hv_free(x) _mm_free(x)
 168:source/HvUtils.h ****   #elif HV_SIMD_NEON
 169:source/HvUtils.h ****     // malloc on ios always has 16-byte alignment
 170:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 171:source/HvUtils.h ****     #define hv_free(x) free(x)
 172:source/HvUtils.h ****   #else // HV_SIMD_NONE
 173:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 174:source/HvUtils.h ****     #define hv_free(x) free(x)
 175:source/HvUtils.h ****   #endif
 176:source/HvUtils.h **** #else
 177:source/HvUtils.h ****   #include <alloca.h>
 178:source/HvUtils.h ****   #define hv_alloca(_n) alloca(_n)
 179:source/HvUtils.h ****   #define hv_realloc(a, b) realloc(a, b)
 180:source/HvUtils.h ****   #if HV_SIMD_AVX
 181:source/HvUtils.h ****     #define hv_malloc(_n) aligned_alloc(32, _n)
 182:source/HvUtils.h ****     #define hv_free(x) free(x)
 183:source/HvUtils.h ****   #elif HV_SIMD_SSE
 184:source/HvUtils.h ****     #define hv_malloc(_n) aligned_alloc(16, _n)
 185:source/HvUtils.h ****     #define hv_free(x) free(x)
 186:source/HvUtils.h ****   #elif HV_SIMD_NEON
 187:source/HvUtils.h ****     #if HV_ANDROID
 188:source/HvUtils.h ****       #define hv_malloc(_n) memalign(16, _n)
 189:source/HvUtils.h ****       #define hv_free(x) free(x)
 190:source/HvUtils.h ****     #else
 191:source/HvUtils.h ****       #define hv_malloc(_n) aligned_alloc(16, _n)
 192:source/HvUtils.h ****       #define hv_free(x) free(x)
 193:source/HvUtils.h ****     #endif
 194:source/HvUtils.h ****   #else // HV_SIMD_NONE
 195:source/HvUtils.h ****     #define hv_malloc(_n) malloc(_n)
 196:source/HvUtils.h ****     #define hv_free(_n) free(_n)
 197:source/HvUtils.h ****   #endif
 198:source/HvUtils.h **** #endif
 199:source/HvUtils.h **** 
 200:source/HvUtils.h **** // Assert
 201:source/HvUtils.h **** #include <assert.h>
 202:source/HvUtils.h **** #define hv_assert(e) assert(e)
 203:source/HvUtils.h **** 
 204:source/HvUtils.h **** // Export and Inline
 205:source/HvUtils.h **** #if HV_MSVC
 206:source/HvUtils.h **** #define HV_EXPORT __declspec(dllexport)
 207:source/HvUtils.h **** #define inline __inline
 208:source/HvUtils.h **** #define HV_FORCE_INLINE __forceinline
 209:source/HvUtils.h **** #else
 210:source/HvUtils.h **** #define HV_EXPORT
 211:source/HvUtils.h **** #define HV_FORCE_INLINE inline __attribute__((always_inline))
 212:source/HvUtils.h **** #endif
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 15


 213:source/HvUtils.h **** 
 214:source/HvUtils.h **** #ifdef __cplusplus
 215:source/HvUtils.h **** extern "C" {
 216:source/HvUtils.h **** #endif
 217:source/HvUtils.h ****   // Returns a 32-bit hash of any string. Returns 0 if string is NULL.
 218:source/HvUtils.h ****   hv_uint32_t hv_string_to_hash(const char *str);
 219:source/HvUtils.h **** #ifdef __cplusplus
 220:source/HvUtils.h **** }
 221:source/HvUtils.h **** #endif
 222:source/HvUtils.h **** 
 223:source/HvUtils.h **** // Math
 224:source/HvUtils.h **** #include <math.h>
 225:source/HvUtils.h **** static inline hv_size_t __hv_utils_max_ui(hv_size_t x, hv_size_t y) { return (x > y) ? x : y; }
 226:source/HvUtils.h **** static inline hv_size_t __hv_utils_min_ui(hv_size_t x, hv_size_t y) { return (x < y) ? x : y; }
 227:source/HvUtils.h **** static inline hv_int32_t __hv_utils_max_i(hv_int32_t x, hv_int32_t y) { return (x > y) ? x : y; }
 228:source/HvUtils.h **** static inline hv_int32_t __hv_utils_min_i(hv_int32_t x, hv_int32_t y) { return (x < y) ? x : y; }
 335              		.loc 3 228 26 discriminator 1 view .LVU82
 336              	.LBB120:
 337              		.loc 3 228 73 discriminator 1 view .LVU83
 338              		.loc 3 228 92 is_stmt 0 discriminator 1 view .LVU84
 339 005e 8142     		cmp	r1, r0
 340 0060 A8BF     		it	ge
 341 0062 0146     		movge	r1, r0
 342              	.LVL22:
 343              	.L12:
 344              		.loc 3 228 92 discriminator 1 view .LVU85
 345              	.LBE120:
 346              	.LBE119:
  33:source/HvControlSlice.c ****         msg_init(n, x, msg_getTimestamp(m));
 347              		.loc 2 33 9 is_stmt 1 view .LVU86
 348              	.LBB121:
 349              	.LBI121:
  57:source/HvMessage.h ****   hv_assert(numElements > 0);
 350              		.loc 1 57 25 view .LVU87
 351              	.LBB122:
  58:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
 352              		.loc 1 58 3 view .LVU88
 353 0064 0029     		cmp	r1, #0
 354 0066 3BD0     		beq	.L24
  59:source/HvMessage.h **** }
 355              		.loc 1 59 3 view .LVU89
  59:source/HvMessage.h **** }
 356              		.loc 1 59 28 is_stmt 0 view .LVU90
 357 0068 4A1C     		adds	r2, r1, #1
 358              	.LBE122:
 359              	.LBE121:
  34:source/HvControlSlice.c ****         hv_memcpy(&n->elem, &m->elem+o->i, x*sizeof(Element));
 360              		.loc 2 34 9 view .LVU91
 361 006a 9946     		mov	r9, r3
  33:source/HvControlSlice.c ****         msg_init(n, x, msg_getTimestamp(m));
 362              		.loc 2 33 24 view .LVU92
 363 006c 6B46     		mov	r3, sp
 364              	.LVL23:
 365              	.LBB127:
 366              	.LBB125:
  59:source/HvMessage.h **** }
 367              		.loc 1 59 28 view .LVU93
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 16


 368 006e D600     		lsls	r6, r2, #3
 369              	.LVL24:
  59:source/HvMessage.h **** }
 370              		.loc 1 59 28 view .LVU94
 371              	.LBE125:
 372              	.LBE127:
  33:source/HvControlSlice.c ****         msg_init(n, x, msg_getTimestamp(m));
 373              		.loc 2 33 24 view .LVU95
 374 0070 A3EBC203 		sub	r3, r3, r2, lsl #3
  34:source/HvControlSlice.c ****         hv_memcpy(&n->elem, &m->elem+o->i, x*sizeof(Element));
 375              		.loc 2 34 9 view .LVU96
 376 0074 59F8082B 		ldr	r2, [r9], #8
 377              	.LVL25:
  33:source/HvControlSlice.c ****         msg_init(n, x, msg_getTimestamp(m));
 378              		.loc 2 33 24 view .LVU97
 379 0078 9D46     		mov	sp, r3
 380 007a E846     		mov	r8, sp
 381              	.LVL26:
  34:source/HvControlSlice.c ****         hv_memcpy(&n->elem, &m->elem+o->i, x*sizeof(Element));
 382              		.loc 2 34 9 is_stmt 1 view .LVU98
 383              	.LBB128:
 384              	.LBI128:
  82:source/HvMessage.h ****   return m->timestamp;
 385              		.loc 1 82 27 view .LVU99
 386              	.LBB129:
  83:source/HvMessage.h **** }
 387              		.loc 1 83 3 view .LVU100
  83:source/HvMessage.h **** }
 388              		.loc 1 83 3 is_stmt 0 view .LVU101
 389              	.LBE129:
 390              	.LBE128:
  34:source/HvControlSlice.c ****         hv_memcpy(&n->elem, &m->elem+o->i, x*sizeof(Element));
 391              		.loc 2 34 9 view .LVU102
 392 007c 4046     		mov	r0, r8
 393 007e FFF7FEFF 		bl	msg_init
 394              	.LVL27:
  35:source/HvControlSlice.c ****         sendMessage(_c, 0, n);
 395              		.loc 2 35 9 is_stmt 1 view .LVU103
 396 0082 2168     		ldr	r1, [r4]
 397 0084 A6F10802 		sub	r2, r6, #8
 398 0088 08F10800 		add	r0, r8, #8
 399 008c 09EBC101 		add	r1, r9, r1, lsl #3
 400 0090 FFF7FEFF 		bl	memcpy
 401              	.LVL28:
  36:source/HvControlSlice.c ****       } else {
 402              		.loc 2 36 9 view .LVU104
 403 0094 BB6A     		ldr	r3, [r7, #40]
 404 0096 4246     		mov	r2, r8
 405 0098 0021     		movs	r1, #0
 406 009a 2846     		mov	r0, r5
 407 009c 9847     		blx	r3
 408              	.LVL29:
 409              	.LBE131:
 410              		.loc 2 62 1 is_stmt 0 view .LVU105
 411 009e 0C37     		adds	r7, r7, #12
 412              		.cfi_remember_state
 413              		.cfi_def_cfa_offset 28
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 17


 414 00a0 BD46     		mov	sp, r7
 415              		.cfi_def_cfa_register 13
 416              		@ sp needed
 417 00a2 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 418              	.LVL30:
 419              	.L9:
 420              		.cfi_restore_state
  55:source/HvControlSlice.c ****         o->n = (int) msg_getFloat(m,0);
 421              		.loc 2 55 7 is_stmt 1 view .LVU106
 422              	.LBB132:
 423              	.LBI132:
 125:source/HvMessage.h ****   return (index < msg_getNumElements(m)) ? (msg_getType(m,index) == HV_MSG_FLOAT) : false;
 424              		.loc 1 125 20 view .LVU107
 425              	.LBB133:
 426              		.loc 1 126 3 view .LVU108
 427              	.LBB134:
 428              	.LBI134:
  90:source/HvMessage.h ****   return (int) m->numElements;
 429              		.loc 1 90 19 view .LVU109
 430              	.LBB135:
  91:source/HvMessage.h **** }
 431              		.loc 1 91 3 view .LVU110
  91:source/HvMessage.h **** }
 432              		.loc 1 91 3 is_stmt 0 view .LVU111
 433              	.LBE135:
 434              	.LBE134:
 435              		.loc 1 126 83 view .LVU112
 436 00a6 9A88     		ldrh	r2, [r3, #4]
 437              	.LVL31:
 438              		.loc 1 126 83 view .LVU113
 439 00a8 002A     		cmp	r2, #0
 440 00aa B3D0     		beq	.L7
 441              	.LVL32:
 442              	.LBB136:
 443              	.LBI136:
  99:source/HvMessage.h ****   hv_assert(index < msg_getNumElements(m)); // invalid index
 444              		.loc 1 99 27 is_stmt 1 view .LVU114
 445              	.LBB137:
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 446              		.loc 1 100 3 view .LVU115
 100:source/HvMessage.h ****   return (&(m->elem)+index)->type;
 447              		.loc 1 100 3 is_stmt 0 view .LVU116
 448              	.LBE137:
 449              	.LBE136:
 450              	.LBE133:
 451              	.LBE132:
  91:source/HvMessage.h **** }
 452              		.loc 1 91 3 is_stmt 1 view .LVU117
 453              	.LBB141:
 454              	.LBB140:
 455              	.LBB139:
 456              	.LBB138:
 101:source/HvMessage.h **** }
 457              		.loc 1 101 3 view .LVU118
 101:source/HvMessage.h **** }
 458              		.loc 1 101 3 is_stmt 0 view .LVU119
 459              	.LBE138:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 18


 460              	.LBE139:
 461              		.loc 1 126 83 view .LVU120
 462 00ac 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 463 00ae 012A     		cmp	r2, #1
 464 00b0 B0D1     		bne	.L7
 465              	.LVL33:
 466              		.loc 1 126 83 view .LVU121
 467              	.LBE140:
 468              	.LBE141:
 469              	.LBB142:
 470              	.LBB143:
 122:source/HvMessage.h **** }
 471              		.loc 1 122 3 is_stmt 1 view .LVU122
 122:source/HvMessage.h **** }
 472              		.loc 1 122 3 is_stmt 0 view .LVU123
 473              	.LBE143:
 474              	.LBE142:
  56:source/HvControlSlice.c ****       }
 475              		.loc 2 56 16 view .LVU124
 476 00b2 D3ED037A 		vldr.32	s15, [r3, #12]
 477              		.loc 2 62 1 view .LVU125
 478 00b6 0C37     		adds	r7, r7, #12
 479              		.cfi_remember_state
 480              		.cfi_def_cfa_offset 28
  56:source/HvControlSlice.c ****       }
 481              		.loc 2 56 16 view .LVU126
 482 00b8 FDEEE77A 		vcvt.s32.f32	s15, s15
 483 00bc C1ED017A 		vstr.32	s15, [r1, #4]	@ int
 484              		.loc 2 62 1 view .LVU127
 485 00c0 BD46     		mov	sp, r7
 486              		.cfi_def_cfa_register 13
 487              		@ sp needed
 488 00c2 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 489              	.LVL34:
 490              	.L11:
 491              		.cfi_restore_state
 492              	.LBB144:
  39:source/HvControlSlice.c ****         msg_initWithBang(n, msg_getTimestamp(m));
 493              		.loc 2 39 9 is_stmt 1 view .LVU128
  39:source/HvControlSlice.c ****         msg_initWithBang(n, msg_getTimestamp(m));
 494              		.loc 2 39 9 is_stmt 0 view .LVU129
 495              	.LBE144:
  58:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
 496              		.loc 1 58 3 is_stmt 1 view .LVU130
  59:source/HvMessage.h **** }
 497              		.loc 1 59 3 view .LVU131
 498              	.LBB147:
  39:source/HvControlSlice.c ****         msg_initWithBang(n, msg_getTimestamp(m));
 499              		.loc 2 39 24 is_stmt 0 view .LVU132
 500 00c6 84B0     		sub	sp, sp, #16
  40:source/HvControlSlice.c ****         sendMessage(_c, 1, n);
 501              		.loc 2 40 9 view .LVU133
 502 00c8 1968     		ldr	r1, [r3]
  39:source/HvControlSlice.c ****         msg_initWithBang(n, msg_getTimestamp(m));
 503              		.loc 2 39 24 view .LVU134
 504 00ca 6A46     		mov	r2, sp
 505              	.LVL35:
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 19


  40:source/HvControlSlice.c ****         sendMessage(_c, 1, n);
 506              		.loc 2 40 9 is_stmt 1 view .LVU135
 507              	.LBB145:
 508              	.LBI145:
  82:source/HvMessage.h ****   return m->timestamp;
 509              		.loc 1 82 27 view .LVU136
 510              	.LBB146:
  83:source/HvMessage.h **** }
 511              		.loc 1 83 3 view .LVU137
  83:source/HvMessage.h **** }
 512              		.loc 1 83 3 is_stmt 0 view .LVU138
 513              	.LBE146:
 514              	.LBE145:
  40:source/HvControlSlice.c ****         sendMessage(_c, 1, n);
 515              		.loc 2 40 9 view .LVU139
 516 00cc 1046     		mov	r0, r2
 517              	.LVL36:
  40:source/HvControlSlice.c ****         sendMessage(_c, 1, n);
 518              		.loc 2 40 9 view .LVU140
 519 00ce 7A60     		str	r2, [r7, #4]
 520 00d0 FFF7FEFF 		bl	msg_initWithBang
 521              	.LVL37:
  41:source/HvControlSlice.c ****       }
 522              		.loc 2 41 9 is_stmt 1 view .LVU141
 523 00d4 7A68     		ldr	r2, [r7, #4]
 524 00d6 0121     		movs	r1, #1
 525 00d8 2846     		mov	r0, r5
 526 00da BB6A     		ldr	r3, [r7, #40]
 527 00dc 9847     		blx	r3
 528              	.LVL38:
 529 00de 99E7     		b	.L7
 530              	.LVL39:
 531              	.L24:
  41:source/HvControlSlice.c ****       }
 532              		.loc 2 41 9 is_stmt 0 view .LVU142
 533              	.LBE147:
 534              	.LBB148:
 535              	.LBB130:
 536              	.LBB126:
 537              	.LBB123:
 538              	.LBI123:
  57:source/HvMessage.h ****   hv_assert(numElements > 0);
 539              		.loc 1 57 25 is_stmt 1 view .LVU143
 540              	.LBB124:
  58:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
 541              		.loc 1 58 3 is_stmt 0 view .LVU144
 542 00e0 024B     		ldr	r3, .L25
 543              	.LVL40:
  58:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
 544              		.loc 1 58 3 view .LVU145
 545 00e2 3A21     		movs	r1, #58
 546              	.LVL41:
  58:source/HvMessage.h ****   return sizeof(HvMessage) + ((numElements-1) * sizeof(Element));
 547              		.loc 1 58 3 view .LVU146
 548 00e4 024A     		ldr	r2, .L25+4
 549 00e6 0348     		ldr	r0, .L25+8
 550 00e8 FFF7FEFF 		bl	__assert_func
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 20


 551              	.LVL42:
 552              	.L26:
 553              		.align	2
 554              	.L25:
 555 00ec 00000000 		.word	.LC2
 556 00f0 00000000 		.word	.LANCHOR1
 557 00f4 20000000 		.word	.LC1
 558              	.LBE124:
 559              	.LBE123:
 560              	.LBE126:
 561              	.LBE130:
 562              	.LBE148:
 563              		.cfi_endproc
 564              	.LFE400:
 566              		.section	.rodata.__func__.0,"a"
 567              		.align	2
 568              		.set	.LANCHOR0,. + 0
 571              	__func__.0:
 572 0000 6D73675F 		.ascii	"msg_getFloat\000"
 572      67657446 
 572      6C6F6174 
 572      00
 573              		.section	.rodata.__func__.2,"a"
 574              		.align	2
 575              		.set	.LANCHOR1,. + 0
 578              	__func__.2:
 579 0000 6D73675F 		.ascii	"msg_getCoreSize\000"
 579      67657443 
 579      6F726553 
 579      697A6500 
 580              		.text
 581              	.Letext0:
 582              		.file 4 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/machine/_default_types.h"
 583              		.file 5 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/sys/_stdint.h"
 584              		.file 6 "/Library/DaisyToolchain/0.2.0/arm/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 585              		.file 7 "source/HvHeavy.h"
 586              		.file 8 "source/HvControlSlice.h"
 587              		.file 9 "/Library/DaisyToolchain/0.2.0/arm/arm-none-eabi/include/assert.h"
 588              		.file 10 "<built-in>"
ARM GAS  /var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s 			page 21


DEFINED SYMBOLS
                            *ABS*:0000000000000000 HvControlSlice.c
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:19     .rodata.msg_getFloat.part.0.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:26     .text.msg_getFloat.part.0:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:32     .text.msg_getFloat.part.0:0000000000000000 msg_getFloat.part.0
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:56     .text.msg_getFloat.part.0:0000000000000010 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:63     .text.cSlice_init:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:70     .text.cSlice_init:0000000000000000 cSlice_init
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:94     .rodata.cSlice_onMessage.str1.4:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:98     .text.cSlice_onMessage:0000000000000000 $t
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:105    .text.cSlice_onMessage:0000000000000000 cSlice_onMessage
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:555    .text.cSlice_onMessage:00000000000000ec $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:567    .rodata.__func__.0:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:571    .rodata.__func__.0:0000000000000000 __func__.0
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:574    .rodata.__func__.2:0000000000000000 $d
/var/folders/fb/yfxt3z4538j6z0vjt03w70vc0000gn/T//ccowmZ23.s:578    .rodata.__func__.2:0000000000000000 __func__.2

UNDEFINED SYMBOLS
__assert_func
msg_init
memcpy
msg_initWithBang
